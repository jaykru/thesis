<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2021-09-25 Sat 13:28 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>9/14: Up to Speed on Sterling &amp; Spitters</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Jay Kruer" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<script type="text/javascript">
// @license magnet:?xt=urn:btih:e95b018ef3580986a04669f1b5879592219e2a7a&dn=public-domain.txt Public Domain
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">9/14: Up to Speed on Sterling &amp; Spitters</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgb658448">1. Reminders of some notions from my first chapter</a></li>
<li><a href="#org4828860">2. The Yoneda embedding and normalization by evaluation</a>
<ul>
<li><a href="#org3c4c8b8">2.1. Normalization? Evaluation?</a></li>
<li><a href="#org92a89fd">2.2. Reflection, reification</a></li>
<li><a href="#org8e44544">2.3. Back to SterSpit</a></li>
</ul>
</li>
<li><a href="#orge569115">3. A pickle: too much quotienting</a></li>
<li><a href="#org8d886b3">4. Unpickling ourselves: the category of renamings</a></li>
<li><a href="#orgba71462">5. The relative hom functor</a></li>
</ul>
</div>
</div>
<div id="outline-container-orgb658448" class="outline-2">
<h2 id="orgb658448"><span class="section-number-2">1</span> Reminders of some notions from my first chapter</h2>
<div class="outline-text-2" id="text-1">
<p>
Review the category of contexts and substitutions, I can do this live.
</p>
</div>
</div>
<div id="outline-container-org4828860" class="outline-2">
<h2 id="org4828860"><span class="section-number-2">2</span> The Yoneda embedding and normalization by evaluation</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-org3c4c8b8" class="outline-3">
<h3 id="org3c4c8b8"><span class="section-number-3">2.1</span> Normalization? Evaluation?</h3>
<div class="outline-text-3" id="text-2-1">
<p>
Normalization by evaluation is a technique used to demonstrate normalization&#x2013;
the property that all terms have a normal form&#x2013;for some lambda calculus.
Andreas Abel renders the technique very clearly<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup>: Normalization is the
process of bringing an open term (with unknowns) to a special kind of fixed
point. A similar notion is evaluation, the process of bringing a <i>closure</i>,
namely an open term paired with a substitution closing it, to a canonical form
comprised entirely of constructors.
</p>

<p>
<b>Normalization by evaluation</b> borrows an exist evaluator for some sufficiently
expressive host language and uses it to normalize an open expression in the
guest language we're interested in. The basic plot outline is this, each step
paired with the relevant code from an instance<sup><a id="fnr.2" class="footref" href="#fn.2">2</a></sup> of normalization with the host
being Standard ML and the guest being the simply typed lambda calculus:
</p>
<ol class="org-ol">
<li><p>
Create in the host language an internal representation of the guest language syntax and type structure:
</p>
<div class="org-src-container">
<pre class="src src-sml">datatype ty = Basic of string
	    | Arrow of ty * ty
	    | Prod of ty * ty

datatype tm = var of string
	    | lam of string * tm | app of tm * tm
	    | pair of tm * tm | fst of tm | snd of tm
</pre>
</div></li>
<li><p>
Building a semantic model (a la actions) of the guest language in terms of host language constructs:
</p>

<div class="org-src-container">
<pre class="src src-sml">datatype sem = LAM of (sem -&gt; sem)
	     | PAIR of sem * sem
	     | SYN of tm
</pre>
</div>

<p>
   Here, our model expresses lambda expressions in STLC as <i>actual ML
functions</i> and pairs as <i>actual ML pairs</i>. We also allow for embedding syntax
terms of our base type, which have no further structure, into the semantics.
</p></li>

<li>Defining a mutually recursive pair of type-indexed operation families called
reification and reflection, detailed in the next section, whose composition
acts as a normalization function.</li>
<li>Compose reification with reflection to get a normalization function for terms
in the guest language.</li>
</ol>
</div>
</div>

<div id="outline-container-org92a89fd" class="outline-3">
<h3 id="org92a89fd"><span class="section-number-3">2.2</span> Reflection, reification</h3>
<div class="outline-text-3" id="text-2-2">
<p>
<img src="nbe.png" alt="nbe.png" />
Reflection is the operation which takes a syntactic lambda term, namely
something in <code>tm</code>, and produces the corresponding semantic representation in
<code>sem</code>. The instance from Wikipedia features the following reflection operation
defined mutually with reification:
</p>
<div class="org-src-container">
<pre class="src src-sml"> (* reflect : ty -&gt; tm -&gt; sem *)
 fun reflect (Arrow (a, b)) t =
       LAM (fn S =&gt; reflect b (app t (reify a S)))
   | reflect (Prod (a, b)) t =
       PAIR (reflect a (fst t)) (reflect b (snd t))
   | reflect (Basic _) t =
       SYN t

(* reify : ty -&gt; sem -&gt; tm *)
 and reify (Arrow (a, b)) (LAM S) =
       let x = fresh_var () in
	 lam (x, reify b (S (reflect a (var x))))
       end
   | reify (Prod (a, b)) (PAIR S T) =
       pair (reify a S, reify b T)
   | reify (Basic _) (SYN t) = t
</pre>
</div>

<p>
I'll start my explanation of this with reification, because it will come first
in the normalization function we're building. In its first case, we want to
reflect a syntactic function (something of arrow type) into our semantics. To do
so, we create a new ML function (with a lambda expression) which reflects into
the semantics the result of applying the syntactic function to the reification
of its parameter. This resembles the usual eta-expansion for terms of function
type, in which we take \( f: A \rightarrow B\) to the term \( \lambda a.\, f a
\). The pair case has a similarly eta-expansive flavor. The case for the base
type just embeds the term into the semantics.
</p>

<p>
Reification is just like reflection but with the parity of
reflection/reification calls flipped everywhere. As before, for function types
we perform something like eta-expansion; only here we can't rely on the
meta-language to handle variable freshness issues and we have to allocate
hitherto-unbound variables ourselves. Pairs are similar, without the variable
complication. The case of the base type amounts to undoing the embedding
performed by reflect.
</p>

<p>
One can show that the composition <code>fun t. reify (reflect (t))</code> is a normalization
function for the simply typed lambda calculus.
</p>
</div>
</div>

<div id="outline-container-org8e44544" class="outline-3">
<h3 id="org8e44544"><span class="section-number-3">2.3</span> Back to SterSpit</h3>
<div class="outline-text-3" id="text-2-3">
<p>
The first big claim in SterSpit is that a special version of the Yoneda
embedding (with more intensional flavor) defines a reflection operation from the
syntactic category into its category of presheaves. SterSpit promise a
corresponding reification operation to complete the normalization by evaluation
story, but delay its introduction until a few sections past what I've managed to
understand so far. For now, we have a problem.
</p>
</div>
</div>
</div>

<div id="outline-container-orge569115" class="outline-2">
<h2 id="orge569115"><span class="section-number-2">3</span> A pickle: too much quotienting</h2>
<div class="outline-text-2" id="text-3">
<p>
The definition of the syntactic category (category of contexts and
substitutions) given in the chapter I wrote a few weeks ago has for its
equations governing equality of morphisms those given by the "substitution
lemma." It turns out that this identifies far too many terms for our uses. In
particular, terms which are related by the various beta rules are identified,
meaning that a normal form (a term for which no further beta reduction can be
performed) is identified with its (manifestly not normal) beta-predecessor. The
upshot is that we can't isolate the normal forms as a class of terms, which
totally bungles our whole project of investigating which terms (all of them) of
the simply typed lambda calculus have normal forms. To spell it out: the
normalization by evaluation function SterSpit propose is actually equal to the
identity on the syntactic category. The whole point of using the gluing
construction is to get us out of this situation by introducing more
computational information that allows us to distinguish terms from their
beta-ancestors and beta-posteriors.
</p>
</div>
</div>

<div id="outline-container-org8d886b3" class="outline-2">
<h2 id="org8d886b3"><span class="section-number-2">4</span> Unpickling ourselves: the category of renamings</h2>
<div class="outline-text-2" id="text-4">
<p>
As an alternative to the misbehaving category of contexts and substitutions, we
will work with the catetory of renamings. In simple terms, this category has as
its objects all contexts over our types and whose morphisms are type-preserving
changes of variable from one context to another. Unfortunately as I found while
typing this up, the simple rendition is somewhat ill-specified. Fiore (2002)
defines this category as the opposite of the comma category \( \mathfrak{i}
\downarrow \mathfrak{T} \) where \( \mathfrak{i} \) is the functor embedding the
category \( \mathbb{F} \) of finite sets of variables (drawn from the supply of
our algebraic theory) into \( \mathfrak{Set} \) and \( \mathfrak{T} \) is the
constant functor for our set of types \( \mathfrak{T} \). Concretely, its
objects are maps \( \Gamma : V \rightarrow \mathfrak{T} \), i.e., exactly
contexts assigning types to finitely many variables. The morphisms \( \Gamma'
\rightarrow \Gamma \) (of the opposite we'll be working with) are functions \(
\rho : \text{dom}(\Gamma) \rightarrow \text{dom}(\Gamma') \) such that \(\Gamma
= \Gamma' \circ \rho \), i.e., the morphisms are type-preserving changes of
variables. The reason we work with the opposite of this category is so that the
action of the category of the renamings acts contravariantly on the clones of
the syntactic category it embeds in; i.e., we want the arrows to line up with
the syntactic category.
</p>
</div>
</div>

<div id="outline-container-orgba71462" class="outline-2">
<h2 id="orgba71462"><span class="section-number-2">5</span> The relative hom functor</h2>
<div class="outline-text-2" id="text-5">
<p>
Sterling &amp; Spitters follow Fiore in defining the "relative hom functor", which
they suggestively call \(\mathfrak{Tm} : \text{Cl}_{\Sigma} \rightarrow
{\text{Ren}_\Sigma}^{\mathfrak{Set}} \). The suggestion hinted at by the name,
that this functor defines a presheaf of open terms, turns out to be a small lie.
Let's look at what it actually does. \(\mathfrak{Tm}\) is defined by adjusting
the hom functor (i.e, the Yoneda embedding) by precomposition with the inclusion
of the category of renamings into the category of (contexts and) substitutions.
In particular, SterSpit define \(\mathfrak{Tm}(\Delta) = \text{Cl}_{\Sigma}
[i(-), \Delta]\). In plain terms, \( \mathfrak{Tm}(\Delta)\) takes a context in
the category of renamings to the <i>substitutions on terms</i> <b>out of</b> \(\Delta\)
(recalling that the action of the category of contexts on its clones is
contravariant). This can be construed as a presheaf of open terms. For any type
\( \tau \) and any context \( \Gamma \), the morphisms in this set are (in their
totality):
</p>
<ol class="org-ol">
<li>Single substitutions \( [t / x] \) where \( \Gamma \vdash t : \tau \). (Note
that this includes renamings); and,</li>
<li>Context weakenings \( \hat{y} \)</li>
</ol>

<p>
Ignoring the weakenings, we see that we have a presheaf of open terms closed by
\( \Gamma \).
</p>

<p>
The suggestion does break down when generalizing the target context from a
single \( \tau \). For contexts \( \Delta \) and \( \Gamma \), we have
\(\mathfrak{Tm}(\Delta)(\Gamma) = \text{Cl}_{\Sigma} [i(\Gamma), \Delta]\), the
context \( \Gamma \) just falls through the inclusion and we get the
substitutions \( \gamma^{*} : \Delta \vdash \tau \rightarrow \Gamma \vdash \tau
\) for arbitrary \( \tau \). Now here comes the (small) lie: the morphisms in
the syntactic category aren't just single substitutions, but also (as before)
single omissions \( \hat{x}\) and all the compositions of these two classes of
maps.
</p>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
<a href="https://www.cse.chalmers.se/~abela/talkEAFIT2017.pdf">https://www.cse.chalmers.se/~abela/talkEAFIT2017.pdf</a>
</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2">2</a></sup> <div class="footpara"><p class="footpara">
<a href="https://en.wikipedia.org/wiki/Normalisation_by_evaluation">https://en.wikipedia.org/wiki/Normalisation_by_evaluation</a>
</p></div></div>


</div>
</div></div>
<div id="postamble" class="status">
<p class="author">Author: Jay Kruer</p>
<p class="date">Created: 2021-09-25 Sat 13:28</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
