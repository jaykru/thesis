<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2021-09-13 Mon 19:59 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>9/14: Up to Speed on Stirling &amp; Spitters</title>
<meta name="author" content="Jay Kruer" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
</style>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">9/14: Up to Speed on Stirling &amp; Spitters</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org4447ef9">1. Reminders of some notions from my first chapter</a></li>
<li><a href="#orge10c9c1">2. Two Yoneda embeddings and normalization by evaluation</a>
<ul>
<li><a href="#org8fa2d67">2.1. Normalization by evaluation</a></li>
<li><a href="#org12c53e8">2.2. Reflection, reification</a></li>
<li><a href="#orgf90f07f">2.3. The readback used in StirSpit</a></li>
</ul>
</li>
<li><a href="#org9ffd95b">3. A pickle: too much quotienting</a></li>
<li><a href="#orgbefbf3c">4. Unpickling ourselves: the category of renamings</a></li>
<li><a href="#orgc832f56">5. The relative hom functor</a></li>
</ul>
</div>
</div>
<div id="outline-container-org4447ef9" class="outline-2">
<h2 id="org4447ef9"><span class="section-number-2">1.</span> Reminders of some notions from my first chapter</h2>
<div class="outline-text-2" id="text-1">
<p>
Review the category of contexts and substitution
</p>
</div>
</div>
<div id="outline-container-orge10c9c1" class="outline-2">
<h2 id="orge10c9c1"><span class="section-number-2">2.</span> Two Yoneda embeddings and normalization by evaluation</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-org8fa2d67" class="outline-3">
<h3 id="org8fa2d67"><span class="section-number-3">2.1.</span> Normalization by evaluation</h3>
<div class="outline-text-3" id="text-2-1">
<p>
Normalization by evaluation is a technique used to demonstrate normalization&#x2013;
the property that all terms have a normal form&#x2013;for some lambda calculus.
Andreas Abel renders the technique very clearly<sup><a id="fnr.1" class="footref" href="#fn.1" role="doc-backlink">1</a></sup>: Normalization is the
process of bringing an open term (with unknowns) to a special kind of fixed
point. A similar notion is evaluation, the process of bringing a <i>closure</i>,
namely an open term paired with a substitution closing it, to a canonical form
comprised entirely of constructors.
</p>

<p>
<b>Normalization by evaluation</b> borrows an exist evaluator for some sufficiently
expressive host language and uses it to normalize an open expression in the
guest language we&rsquo;re interested in. The basic plot outline is this, each step
paired with the relevant code from an instance<sup><a id="fnr.2" class="footref" href="#fn.2" role="doc-backlink">2</a></sup> of normalization with the host
being Standard ML and the guest being the simply typed lambda calculus:
</p>
<ol class="org-ol">
<li><p>
Create in the host language an internal representation of the guest language syntax and type structure:
</p>
<div class="org-src-container">
<pre class="src src-sml">    <span style="color: #51afef;">datatype</span> <span style="font-weight: bold;">ty</span> = Basic <span style="color: #51afef;">of</span> string
                | Arrow <span style="color: #51afef;">of</span> ty * ty
                | Prod <span style="color: #51afef;">of</span> ty * ty

    <span style="color: #51afef;">datatype</span> <span style="font-weight: bold;">tm</span> = var <span style="color: #51afef;">of</span> string
                | lam <span style="color: #51afef;">of</span> string * tm | app <span style="color: #51afef;">of</span> tm * tm
                | pair <span style="color: #51afef;">of</span> tm * tm | fst <span style="color: #51afef;">of</span> tm | snd <span style="color: #51afef;">of</span> tm
</pre>
</div></li>
<li><p>
Building a semantic model (a la actions) of the guest language in terms of host language constructs:
</p>

<div class="org-src-container">
<pre class="src src-sml">   <span style="color: #51afef;">datatype</span> <span style="font-weight: bold;">sem</span> = LAM <span style="color: #51afef;">of</span> (sem -&gt; sem)
                | PAIR <span style="color: #51afef;">of</span> sem * sem
                | SYN <span style="color: #51afef;">of</span> tm
</pre>
</div>

<p>
   Here, our model expresses lambda expressions in STLC as <i>actual ML
functions</i> and pairs as <i>actual ML pairs</i>. We also allow for embedding syntax
terms of our base type, which have no further structure, into the semantics.
</p></li>

<li>Defining a mutually recursive pair of type-indexed operation families called
reification and reflection, detailed in the next section, whose composition
acts as a normalization function.</li>
<li>Compose reification with reflection to get a normalization function for terms
in the guest language.</li>
</ol>
</div>
</div>

<div id="outline-container-org12c53e8" class="outline-3">
<h3 id="org12c53e8"><span class="section-number-3">2.2.</span> Reflection, reification</h3>
<div class="outline-text-3" id="text-2-2">
<p>
<img src="nbe.png" alt="nbe.png" />
Reflection is the operation which takes a syntactic lambda term, namely
something in <code>tm</code>, and produces the corresponding semantic representation in
<code>sem</code>. The instance from Wikipedia features the following reflection operation
defined mutually with reification:
</p>
<div class="org-src-container">
<pre class="src src-sml"> <span style="color: #5B6268;">(* </span><span style="color: #5B6268;">reflect : ty -&gt; tm -&gt; sem </span><span style="color: #5B6268;">*)</span>
 <span style="color: #51afef;">fun</span> <span style="color: #c678dd;">reflect</span> (Arrow (a, b)) t =
       LAM (<span style="color: #51afef;">fn</span> S =&gt; reflect b (app t (reify a S)))
   | reflect (Prod (a, b)) t =
       PAIR (reflect a (fst t)) (reflect b (snd t))
   | reflect (Basic _) t =
       SYN t

<span style="color: #5B6268;">(* </span><span style="color: #5B6268;">reify : ty -&gt; sem -&gt; tm </span><span style="color: #5B6268;">*)</span>
 <span style="color: #51afef;">and</span> <span style="color: #c678dd;">reify</span> (Arrow (a, b)) (LAM S) =
       <span style="color: #51afef;">let</span> x = fresh_var () <span style="color: #51afef;">in</span>
         lam (x, reify b (S (reflect a (var x))))
       <span style="color: #51afef;">end</span>
   | reify (Prod (a, b)) (PAIR S T) =
       pair (reify a S, reify b T)
   | reify (Basic _) (SYN t) = t
</pre>
</div>

<p>
I&rsquo;ll start my explanation of this with reification, because it will be the I&rsquo;ll
briefly explain what&rsquo;s going on in the first case of reification, in which we
want to reflect a syntactic function (something of arrow type) into our
semantics. In this case, we create a new ML function (with a lambda expression)
which reflects into the semantics the result of applying the syntactic function
to the reification of its parameter. This resembles an eta-expansion for terms
of function type, in which we take \( f: A \rightarrow B\) to the term \(
\lambda a.\, f a \). The pair case has a similarly eta-expansive flavor. The
case for the base type just embeds the term into the semantics.
</p>
</div>
</div>


<div id="outline-container-orgf90f07f" class="outline-3">
<h3 id="orgf90f07f"><span class="section-number-3">2.3.</span> The readback used in StirSpit</h3>
<div class="outline-text-3" id="text-2-3">
<p>
Note that I haven&rsquo;t yet seen exactly the readback operation (in terms of
presheaves) planned yet. Their presentation is abysmally bad on this point
actually&#x2026;they delay explaining/defining an object of deep conceptual and
technical import to the result until like 10 pages in. Maybe they suppose that
the reader already has experience with normalization by evaluation, which I
guess is kind of fair, but this was personally my first exposure to it in
earnest.
</p>
</div>
</div>
</div>

<div id="outline-container-org9ffd95b" class="outline-2">
<h2 id="org9ffd95b"><span class="section-number-2">3.</span> A pickle: too much quotienting</h2>
<div class="outline-text-2" id="text-3">
<p>
The definition of the syntactic category (category of contexts and
substitutions) given in the chapter I wrote a few weeks ago has for its
equations governing equality of morphisms those given by the &ldquo;substitution
lemma.&rdquo; It turns out that this identifies far too many terms for our uses. In
particular, terms which are related by the various beta rules are identified,
meaning that a normal form (a term for which no further beta reduction can be
performed) is identified with its (manifestly not normal) beta-predecessor. The
upshot is that we can&rsquo;t isolate the normal forms as a class of terms, which
totally bungles our whole project of investigating which terms (all of them) of
the simply typed lambda calculus have normal forms.
</p>
</div>
</div>

<div id="outline-container-orgbefbf3c" class="outline-2">
<h2 id="orgbefbf3c"><span class="section-number-2">4.</span> Unpickling ourselves: the category of renamings</h2>
</div>

<div id="outline-container-orgc832f56" class="outline-2">
<h2 id="orgc832f56"><span class="section-number-2">5.</span> The relative hom functor</h2>
<div class="outline-text-2" id="text-5">
<p>
Stirling &amp; Spitters follow Fiore in defining the &ldquo;relative hom functor&rdquo;, which
they suggestively call \(\mathfrak{Tm} : \text{Cl}_{\Sigma} \rightarrow
{\text{Ren}_\Sigma}^{\mathfrak{Set}} \). The suggestion hinted at by the name,
that this functor defines a presheaf of open terms, turns out to be a (small?)
lie. Let&rsquo;s look at what it actually does. \(\mathfrak{Tm}\) is defined by
adjusting the hom functor (i.e, the Yoneda embedding) by precomposition with the
inclusion of the category of renamings into the category of (contexts and)
substitutions. In particular, StirSpit define \(\mathfrak{Tm}(\Delta) =
\text{Cl}_{\Sigma} [i(-), \Delta]\). In plain terms, \( \mathfrak{Tm}(\Delta)\)
takes a context in the category of renamings to the <i>substitutions on terms</i>
<b>out of</b> \(\Delta\) (recalling that the action of the category of contexts on
its clones is contravariant). This can be (very loosely) construed as a presheaf
of open terms. For a (renaming) context \( \Gamma \), we have
\(\mathfrak{Tm}(\Delta)(\Gamma) = \text{Cl}_{\Sigma} [i(\Gamma), \Delta]\), the
context \( \Gamma \) just falls through and we get the substitutions \(
\gamma^{*} : \Delta \vdash \tau \rightarrow \Gamma \vdash \tau \) for arbitrary
\( \tau \). In particular, any (possibly) open term \( \Delta \vdash t : \tau \)
is included in \( \mathfrak{Tm}(\Delta,\tau)(\Delta) \) as the single
substitution \( [t/x] \). The reason I regard as misleading the suggestion that
the relative hom functor defines a presheaf of open terms is that the morphisms
in the syntactic category aren&rsquo;t just single substitutions, but also single
omissions \( \hat{x}\) and all the compositions of these two classes of maps.
</p>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1" role="doc-backlink">1</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
<a href="https://www.cse.chalmers.se/~abela/talkEAFIT2017.pdf">https://www.cse.chalmers.se/~abela/talkEAFIT2017.pdf</a>
</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2" role="doc-backlink">2</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
<a href="https://en.wikipedia.org/wiki/Normalisation_by_evaluation">https://en.wikipedia.org/wiki/Normalisation_by_evaluation</a>
</p></div></div>


</div>
</div></div>
<div id="postamble" class="status">
<p class="author">Author: Jay Kruer</p>
<p class="date">Created: 2021-09-13 Mon 19:59</p>
</div>
</body>
</html>
