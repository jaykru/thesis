open Core

type ty = Arrow of ty * ty
        | Prod of ty * ty
        | Nat [@@deriving sexp]

type var = string [@@deriving sexp]

let cur : int ref = ref 0

let fresh () : var = let res = Printf.sprintf "var%d" !cur in
                     cur := !cur + 1;
                     res

type syn = Lam of var * ty * syn
         | App of syn * syn

         | Pair of syn * syn
         | P1 of syn
         | P2 of syn

         | Zero
         | Succ of syn
         | Rec of ty * syn * syn * syn (* rec : forall (T: ty), T -> (N -> T -> T) -> N -> T *)

         | Var of var [@@deriving sexp]

(* Note: There are no elimination forms in the semantics; they are represented
   as syntax through the SYN embedding. *)
type sem = LAM of (sem -> sem)
         | PAIR of sem * sem
         | SYN of syn
[@@deriving sexp]

(* reflect is a type-indexed family of functions taking the syntax into the
   semantics *)
let rec reflect (tau : ty) : syn -> sem =
  fun t ->
  match tau with
  | Arrow (a, b) ->
    LAM (fun s -> reflect b (App (t, (reify a s)) ))
  | Prod (a, b) ->
    PAIR ((reflect a (P1 t), (reflect b (P1 t))))
  | Nat ->
    SYN t

and reify (tau : ty) : sem -> syn =
  fun t ->
  match (t, tau) with
  | (LAM s, Arrow (a, b)) ->
    let x = fresh () in
    Lam (x, tau, reify b (s (reflect a (Var x))))
  | (PAIR (l, r), Prod(a,b)) ->
    Pair (reify a l, reify b r)
  | (SYN b, _) ->
    b
  | _ ->
    raise (Failure (Printf.sprintf "Reification failed on (%s : %s)"
                      ([%sexp_of : sem] t |> Sexp.to_string)
                      ([%sexp_of: ty] tau |> Sexp.to_string)))


let rec metarec (tau : ty) (z : 'a) (s : syn -> 'a -> 'a) : syn -> 'a =
  fun n ->
  match n with
  | Zero -> z
  | Succ n ->
    s n (metarec tau z s n)
  | u ->
    let v_z = reify tau z in
    let v_s = reify (Arrow(Nat, (Arrow (tau, tau)))) (LAM (fun n -> match n with
                                                            | SYN n -> LAM(s n)
                                                            | _ -> raise (Failure "in metarec"))) in
    reflect tau (Rec (tau, v_z, v_s, u))

type context = (var * ty) list

(* A valuation is a list semantic terms to be interpreted as an assignment of
   terms to variables in an ordered context *)
type valuation = (var * sem) list


(* we assume that a bad lookup is never performed; this will end up being the
   case as long as we only take the meaning in the valuation generated by the
   context closing a well-typed term. *)
let lookup (x : var) (rho : valuation) : sem =
  List.rev (List.filter ~f:(fun entry -> String.equal (fst entry) x) rho)
  |> fun l -> List.nth_exn l 0
  |> snd

(* Given a context gamma, produces a valuation of reflected variables *)
let reflect_ctx (gamma : context) : valuation =
  List.map ~f:(fun (x,tau) -> (x, reflect tau (Var x))) gamma

(* interprets into the semantics an open term t with respect to a valuation rho
   which closes it *)
let rec interp (t : syn) (rho : valuation): sem =
  match t with
  | Var x ->
    lookup x rho
  | Lam(x, _, b) ->
    LAM (fun s -> interp b (List.append rho [(x,s)]))
  | App(e1, e2) ->
    let LAM e1f = interp e1 rho in
    e1f (interp e2 rho)
  | Pair(e1, e2) ->
    PAIR(interp e1 rho, interp e2 rho)
  | P1 e ->

    let PAIR (l,_) = interp e rho in
    l
  | P2 e ->
    let PAIR (_,r) = interp e rho in
    r
  | Zero -> SYN Zero
  | Succ n ->
    SYN (Succ n)
  | Rec(tau, z, s, n) ->
    let LAM si = interp s rho in (* s : nat -> A -> A *)
    let zi = interp z rho in
    let SYN ni = interp n rho in
    metarec tau zi (fun m -> let LAM(f) = si (SYN m) in f) ni
    [@@warning "-8"]
(* the above incomplete matches are irrefutable on well-typed terms t *)

let nbe (gamma : context) (tau : ty) : syn -> syn =
  fun t -> interp t (reflect_ctx gamma) |> reify tau

(* EXAMPLES:
    nbe [("y", Nat); ("z", Nat)] Nat (App (Lam("x", Nat, Var("y")), Var ("z")));;
    - : syn = Var "y"

   nbe [] Nat (App ((Lam ("z", Nat, (Rec(Nat, Zero, Lam("x",Nat,Lam("y",Nat,(Var "x"))), (Var "z"))))), (Succ Zero)));;
   - : syn = Zero*)
