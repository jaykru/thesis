\documentclass[12pt,twoside]{reedthesis}

\usepackage{graphicx,latexsym}
\usepackage{amssymb,amsthm}
\usepackage{longtable,booktabs,setspace} 
\usepackage[hyphens]{url}
\usepackage{rotating}
\usepackage{hyperref}
\usepackage{outlines}
\usepackage{enumitem} % custom labels

% font stuff
\usepackage{bbm, stmaryrd}
\usepackage{unicode-math} % $this is incompatible with Coloneqq for some reason, and I'm not sure why I used it in the first place...
\usepackage{luatexja} % for memes

\usepackage{amsmath}
\usepackage{mathtools} % paired delimeters
\usepackage{braket}
\usepackage{epigraph} % funny quotes
\usepackage{tikz-cd} % diagrams
\usepackage{quiver} % fancy arrows

\usepackage{mathpartir} % inference rules

\usepackage[
backend=biber,
style=alphabetic,
citestyle=alphabetic
]{biblatex} % better citation style
\addbibresource{thesis.bib}

\hypersetup{
  colorlinks,
  allcolors=black,
  hidelinks,
}

\theoremstyle{definition}
\newtheorem{definition}{Definition}
\newtheorem{example}{Example}
\newtheorem{joke}{Joke}
\newtheorem{notation}{Notation}
\newtheorem{remark}{Remark}
\newtheorem{lemma}{Lemma}
\newtheorem{recall}{Recall}
\newtheorem{theorem}{Theorem}
\newtheorem{corollary}{Corollary}

\include{autodelims}
\include{reallywidetilde}
\include{macros}

\DeclarePairedDelimiter\ceil{\lceil}{\rceil}

% Comment out the natbib line above and uncomment the following two lines to use the new 
% biblatex-chicago style, for Chicago A. Also make some changes at the end where the 
% bibliography is included. 
% \usepackage{biblatex-chicago}
% \bibliography{thesis}

% \usepackage{times} % other fonts are available like times, bookman, charter, palatino

\title{慣性ドリフト: From 0 to Normalization by Gluing in 4.9 seconds\\ A Brisk Drift through Categorical Semantics of Lambda Calculi}
\author{Jay Kruer}
% The month and year that you submit your FINAL draft TO THE LIBRARY (May or December)
\date{December 2021}
\division{Mathematics and Natural Sciences}
\advisor{Ang\'elica Osorno}
\altadvisor{James (Jim) Fix}

\department{Mathematics}
% if you're writing a thesis in an interdisciplinary major,
% uncomment the line below and change the text as appropriate.
% check the Senior Handbook if unsure.
\thedivisionof{The Established Interdisciplinary Committee for Mathematics and Computer Science}
% if you want the approval page to say "Approved for the Committee",
% uncomment the next line
% \approvedforthe{Committee}

\setlength{\parskip}{0pt}

\begin{document}
\maketitle
\frontmatter % this stuff will be roman-numbered
\pagestyle{empty} % this removes page numbers from the frontmatter

% Acknowledgements (Acceptable American spelling) are optional
% So are Acknowledgments (proper English spelling)
\chapter*{Acknowledgements}
% Jaclyn, My parents, Uncle Jay, Grandma, Aunt Susie, Jim Fix for teaching me
% SML what feels like a decade ago and starting me off on this adventure, and
% for being a wonderful advisor throughout my college experience and thesis;
% Ang\'elica Osorno, Irena Swanson, Kyle Ormsby, Albyn Jones, Jaclyn, Nick
% Chaiyachakorn, Ms.\ King, 柳老師 (Hyong Rhew), Mrs.\ Leitsch, Mr. Cool even if
% you couldn't get the team to switch from LabView, Mr.\ Raveli, Noah Koster,
% Shulav, Aditya, Francis, Alec Forget, Joebob, Jit, Eli, Gabe and Ciara, Murali
% Vijayaraghavan, 吳老師, Ian Desai, Becca, Andres, Sara Rosenberger in the
% business office, the GNU project and free software foundation along with the
% developers of so many other free software projects whose generously donated
% works were instrumental in the production of this thesis.

% I'd like to thank Noah Koster for being one of my very first friends at Reed
% and a wonderful companion as I explored the world on my own for the very first
% time. You may not be the next Bill Gates, but you're a great guy.

% Alice McKean

% My van

% Megan, Luke, Ryan, Kathleen

% Young Kim for corrupting my soul
% Salma, Mary, Carter, Dan Genya, Tristan, Max
% Holden

% Hyperbolic gang: Francis, Alec, Kiana, Usman, Luke Doms

% Curtis, Cody Roux and Dan McArdle at the Charles Stark Draper Laboratory for
% early encouragement!

% I would like to give special thanks to Paul Taylor who, though I do not know
% him personally, wrote the book that made this thesis possible. Almost every
% day spent on this project I learned from Paul's book a new awesome perspective
% on the the lambda calculus or mathematics in general. Paul's Practical
% Foundations of Mathemtics is a love letter to the type of computer scientist
% who wants to understand how the world works, and I'm indebted to Paul for
% having created it.

% The preface is optional
% To remove it, comment it out or delete it.
\chapter*{Preface}
\epigraph{And further, by these, my son, be admonished: of making many books
  there is no end; and much study is a weariness of the flesh.}{Ecclesiastes
  12:12, KJV.}

I don't know what to put here, but this is certainly a funny quote that should
find a home somewhere in the thesis.

\chapter*{Notation}
Following the great masters\footnote{\(\mathfrak{Kale\,\, Ormsby}\)}, the face
\( \mathfrak{Mathfrak} \) is used liberally and wherever possible without any
particular convention.


% \chapter*{List of Abbreviations}
% \begin{table}[h]
%   \centering % You could remove this to move table to the left
%   \begin{tabular}{ll}
%     \textbf{TMA}  	&  Too Many Abbreviations
%   \end{tabular}
% \end{table}


\tableofcontents
% if you want a list of tables, optional
\listoftables
% if you want a list of figures, also optional
\listoffigures

% The abstract is not required if you're writing a creative thesis (but aren't they all?)
% If your abstract is longer than a page, there may be a formatting issue.
\chapter*{Abstract}
Normalization by gluing is based.

% \chapter*{Dedication}


\mainmatter% here the regular arabic numbering starts
\pagestyle{fancyplain} % turns page numbering back on

% The \introduction command is provided as a convenience.
% if you want special chapter formatting, you'll probably want to avoid using it altogether

\chapter*{Introduction}
\epigraph{You don't need a weatherman to know which way the wind blows.}{Bob Dylan}
\addcontentsline{toc}{chapter}{Introduction}
\chaptermark{Introduction}
\markboth{Introduction}{Introduction}
% The three lines above are to make sure that the headers are right, that the intro gets included in the table of contents, and that it doesn't get numbered 1 so that chapter one is 1.

% Double spacing: if you want to double space, or one and a half 
% space, uncomment one of the following lines. You can go back to 
% single spacing with the \singlespacing command.
% \onehalfspacing
% \doublespacing

Blah blah blah, I should write some stuff about how category theory helps us
avoid insane proof heuristics in metatheory of type theory.

\chapter{Functorial semantics: sketches and their models; algebraic theories and their algebras}
In this chapter we develop tools for reasoning about (syntactic)
\emph{theories}, which are in some sense ``notions of'' abstract structure.
Examples of theories include the theory of rings, and simple type theory. To
discuss how we write down our theories, we need another level of abstraction. We
will work with several \emph{notions of} (syntactic) theory, and we will more
laconically refer to a notion of syntactic theory as a \emph{doctrine}. A
\emph{doctrine} is something like a meta-framework specifying how we are to
write down a theory. The first doctrine we will consider is that of the
\emph{elementary sketch}. % The reader familiar with and/or traumatized by
% experience with pencils of geodesics in hyperbolic geometry need not be scared
% away by this terminology; there is nothing non-Euclidean afoot here.
The doctrine of the \emph{elementary sketch} allows us to write down theories
involving \emph{unary} operations (those defined over a single argument.) This
restriction on the arity of operations turns out to be quite limiting. To
address this, we will later upgrade the doctrine of elementary sketches to the
doctrine of \emph{algebraic theories} which allow encoding operations with any
finite number of arguments, thus covering a broad variety of theories. Algebraic
theories are known more famously as \emph{Lawvere theories} after categorical
logic superstar (and former Reed College professor!) William Lawvere who
originally studied them while building his functorial treatment of universal
algebra. Keeping with our sketchy terminology and emphasizing the doctrinal
upgrade, algebraic theories are also called \emph{finite product sketches}. As
an example of the strength of algebraic theories, we will show how to write down
(as an algebraic theory) what it means to be a ring, with no reference to sets
or functions. In the following chapter, we will use the doctrine of algebraic
theories to develop categorical semantics of the lambda calculus. This chapter
is strictly expository in nature. Much of the following presentation draws
heavily from Paul Taylor's \emph{Practical Foundations of
  Mathematics}~\cite{taylor_practical_1999}. Our humble contribution is to flesh
out some of his examples, add some of our own, and make parts of the
presentation more palatable and quickly digestible to the reader already
acquainted with basic category theory and type theory.

\section{Elementary sketches and their models}
\subsection{An algebraic prelude}
We begin by recalling from algebra the notion of an \emph{action} of, say, a
group or a monoid. Actions are, from our perspective, a way of giving meaning,
or \emph{semantics} to elements of a set which enjoys some algebraic structure.
\begin{definition}\label{def:covariant action}
  Recall that a \textbf{covariant action} of a group or monoid \((M, id, \cdot)\) on
  a set \(A\) is a binary operation \((-)_* (=) : M ‌\times A \rightarrow A\) such that
  \(\text{id}_* a = a\) and \( (g \circ f)_* a = g_* (f_* a) \). We can similarly a
  define the notion of a \textbf{contravariant action} which similarly requires
  the identity action to do nothing, but instead flips the order of action for
  compositions: $(g \circ f)^{*}a = f^{*}(g^{*} a)$
\end{definition}

For example, in algebra we learn that the dihedral group of order 8, written
$D_{4}$, acts on the square (with uniquely identified points) by reflections and
rotations\footnote{https://groupprops.subwiki.org/wiki/Dihedral\_group:D8}; each
of the operations encoded by the action results in the same image of the square
up to ignoring the unique identity of the points we started with. This action
gives geometric meaning to each of the group elements, and was used in the first
day of the author's algebra class to explain the algebraic mechanics of the
group itself; discovering which elements of the group are inverse to one another
is done by geometric experimentation using a square with uniquely colored
vertices. Similarly, the symmetric groups $S_{n}$ act on lists of length $n$ by
permutation of the list elements. In this case, the action can be even more
trivially defined. We now turn to the definition of an important property of
actions: \emph{faithfulness}.

\begin{definition}\label{def:faithful}
  A \textbf{faithful} action $(-)_{*}$ is one for which things are
  \emph{semantically} equal (or, act the same) only when they are
  \emph{syntactically} equal (or, \emph{are} the same as far as your eyeballs
  are concerned.) More precisely rendered, we
  require: \[ \forall (a:A)\ldotp f_* a = g_* a \Longrightarrow f = g \]
\end{definition}

It can now be seen that the crucial property enjoyed by the natural action of
$D_{8}$ on the square which enabled our use of paper cutouts in studying the
group is faithfulness. If the action were not faithful, determining which
operations in $D_{8}$ are inverses would not be so easy as printing out a square
and plugging away, because we may (among other catastrophes) be working with an
action which may not take only the identity element to the
leave-everything-in-place operation on the square.

Having gesticulated that actions gives groups and monoids their meaning, we turn
to the development of the doctrines of \emph{elementary sketch} and
\emph{algebraic theory} which will allow us to generalize both sets with
algebraic structures and their actions to new settings.

\subsection{Elementary sketches}
As promised, we begin with the definition.
\begin{definition}\label{def:elem sketch}
  An \textbf{elementary sketch} is comprised of the following data:
  \begin{enumerate}
    \item a collection \(X, Y, Z, \dots \) of named \textbf{base types} or
          \textbf{sorts}
    \item a \textbf{variable} \(x:X\) for each occurrence of each named sort.
    \item a collection of \textbf{unary operation-symbols} or
          \textbf{constructors} \(\tau\) having at most one variable. As a
          clarifying example: when sketching type theories, we will write
          \( x:X \vdash \tau(x) : Y \).
    \item a collection of equations or \textbf{laws} of the
          form: \[ \tau_n (\tau_{n-1}(\cdots \tau_2 (\tau_1 (x))\cdots )) = \sigma_m (\sigma_{m-1}(\cdots \sigma_2 (\sigma_1 (x))\cdots )) \]
  \end{enumerate}
\end{definition}

We will discuss the generality provided by this definition after some
intervening examples. One of the simplest examples is the sketch of a (free)
monoid on some set $S$:

\begin{example}[Sketch of a (free) monoid]\label{ex:monoid sketch}
  The requisite data for the sketch are as follows:
  \begin{enumerate}
    \item The collection of sorts is the singleton \( \{M\} \).
    \item The collection of variables is \( \{m:M\} \).
    \item The collection of operation symbols is the set \( S \). Each has as its signature \( M \rightarrow M \)
    \item No equations are imposed.
  \end{enumerate}
\end{example}

To really buy that this sketch generates a free monoid, we need an intervening
definition of a concept we will get a lot of mileage out of in this thesis. The
idea should already be familiar from our study of type theory, despite the
drastically simplified setting.

\begin{definition}\label{def:term}
  Given an elementary sketch, a \textbf{term} $x : \Gamma \vdash X$ is a string of
  composable unary operation-symbols applied to a variable $\gamma : \Gamma$ as in:
  \( \tau_{n} (\tau_{n-1} (\cdots (\tau_{2}(\tau_{1}(\gamma))))) \). Composable unary-operation
  symbols are ones which have compatible domains and codomains in the usual
  sense as in set theory.
\end{definition}

We now propose a more precise version of the above claim: the terms of the
sketch defined above form the elements of a free monoid over $S$. Before we can
continue, we should decide what our term composition will be.

\begin{definition}[Composition of terms]\label{def:term composition}
  Composition of terms is by substitution for the variable: for a term
  \( \sigma : \Delta \vdash \Gamma\) and some terms \( \tau_{i}\) with \( \tau_{n} : \cdots \vdash \Xi \) we define
  \[ (\tau_{n} (\tau_{n-1} (\cdots (\tau_{2}(\tau_{1}(\gamma)))))) \circ \sigma = \tau_{n} (\tau_{n-1} (\cdots (\tau_{2}(\tau_{1}(\sigma(\delta)))))) : \Delta \vdash \Xi. \]
\end{definition}

With our notion of composition in hand, we can now handwave an argument for our
revised claim that the terms of the sketch form the elements of a free monoid.
The reader will recall from our early discussions of basic type theory that
substitution is associative [TODO in Ch 1]. As a consequence, any elementary
sketch, including this one, satisfies that axiom for free. The identity term is
given by zero composable unary operation-symbols applied to a variable. It's
just a variable; when composing the identity term with any other term, we end up
getting exactly that original term.

This loose argument is somewhat satisfying, but we can do better. To get there,
we will first develop a notion generalizing \emph{actions} from algebra. After
doing so, we will give more concrete meaning to this sketch and complete our
intuitive handle on it.

\begin{definition}\label{def:model}
  A \textbf{model} (also known as an algebra, an interpretation, a covariant
  action) of an elementary sketch is comprised of:
  \begin{enumerate}
    \item an assignment of a set $A_X$ to each sort $X$ and
    \item an assignment of a function $\tau_* : A_X \rightarrow A_Y$ for each
    operation-symbol of the appropriate arity such that:
    \item each law is preserved; i.e., for each law as before we have
    \[ {\tau_n}_* ({\tau_{n-1}}_* (\cdots {\tau_2}_* ({\tau_1}_* (x))\cdots )) = {\sigma_m}_* ({\sigma_{m-1}}_*(\cdots {\sigma_2}_* ({\sigma_1}_* (x))\cdots )) \]
    that is, the covariant action on operation-symbols is faithful in
    the sense defined above.
  \end{enumerate}
\end{definition}

The next definition will feature prominently in our later study of type theory,
but will also prove immediately useful in studying Example~\ref{ex:monoid
  sketch} by forming the sets of a ``for-free'' model for any elementary sketch.

\begin{definition}\label{def:clone}
  Given an elementary (unary) sketch, the \textbf{clone} at \( (\Gamma, X) \) is
  the set \( \text{Cn}_{\mathcal{L}} (\Gamma, X) \) of all the \textbf{terms} of sort
  $X$ assuming a single variable of sort $\Gamma$, quotiented by the laws of the
  sketch.
\end{definition}
The fact that a sketch's clones contain \emph{equivalence classes} (with respect
to the laws) of its terms will feature prominently in our later study of ideas
central to the goals of this thesis. In particular, clones alone don't allow for
any meaningful discussion of computational behavior of terms undergoing
reduction; a term's normal form and its various reducible forms are identified
in the clone.

It can be shown that the clones of a sketch form (the sets for) a model of a
sketch. In particular, it can be shown that the sketch acts covariantly on the
set of its clones:
\begin{theorem}\label{thm:clone model}
  Every elementary sketch has a faithful covariant action on its clones
  \(\mathcal{H}_{X} = \cup_{\Gamma} \text{Cn}_{\mathcal{L}}(\Gamma,X)\) by sequencing with
  the operation symbol. Substitution for the (single) variable in a term gives
  a faithful contravariant action on
  \(\mathcal{H}^{Y} = \cup_{\Theta} \text{Cn}_{\mathcal{L}}(Y,\Theta)\).
\end{theorem}
\begin{proof}
  The actions of \(\tau : X \rightarrow Y\) on
  \(\text{Cn}_{\mathcal{L}} (\Gamma,X) \subseteq \mathcal{H}_{X}\) and
  \(\text{Cn}_{\mathcal{L}} (Y,\Theta) \subseteq \mathcal{H}^{Y}\) are given by:
  \begin{itemize}
    \item \(\tau_{*}a_{n}(\cdots a_{2}(a_{2}(\sigma))\cdots) =
    \tau(a_{n}(\cdots(a_{2}(a_{1}(\sigma))))) \in
    \text{Cn}_{\mathcal{L}}(\Gamma,Y)\)
    \item \(\tau^{*}\zeta_{m}(\cdots \zeta_{2}(\zeta_{1}(y))) =
    \zeta_{m}(\cdots\zeta_{2}(\zeta_{1}(\tau(x)))) \in
    \text{Cn}_{\mathcal{L}}(X,\Theta)\)
  \end{itemize}
  where \(\sigma : \Gamma, x : X, \text { and }, y:Y\). Covariance of the
  former is clear. Contravariance of the latter follows by considering the
  behavior of substitutions in sequence.
\end{proof}

\begin{theorem}[The canonical elementary
  language]\label{thm:canonical_elementary_language} Every elementary sketch
  \( \mathcal{L} \) presents a category \( \cn_{\mathcal{L}}\) via the for-free
  action on its clones, and conversely any small category $C$ is presented by
  some sketch $\mathcal{L}$ in the sense that \( C \cong \cn_{\mathcal{L}}\). We
  write \( \lceil-\rceil \) for this isomorphism and call the sketch
  \( L(C) = \mathcal{L} \) the \emph{canonical elementary language} of \( C \).

  The language is defined as follows:
  \begin{itemize}
    \item The sorts \( \lceil X \rceil \) of \( L(C) \) are the objects \( X \) of \( C\)
    \item The operation symbols \( \lceil f \rceil \) are the morphisms \( f \) of \( C \) and
    \item The laws are \( \lceil \id \rceil (x) = x \) and \( \lceil g \rceil (\lceil f \rceil (x)) = \lceil g \circ f \rceil (x) \)
  \end{itemize}

  and the isomorphism is clear.
\end{theorem}

Recalling our sketch of a monoid from Example~\ref{ex:monoid sketch}, the
substance of this covariant action morally amounts to saying that the sketch
acts on its terms by left multiplication (here ``multiplication'' is actually
just juxtaposition plus some parentheses) which gives the robust version of the
handwavy argument we provided above.

\begin{joke}
  A couple of type theorists walk into a Michelin starred restaurant. The menu
  reads in blackboard bold letters $\mathbbm{``NO\, SUBSTITUTIONS''}$. They promptly leave.
\end{joke}

\subsection{The category of contexts and substitutions}
We now introduce a very special category. This category is special in both the
structure it enjoys as well as the central role it will play in the rest of the
thesis. This category goes by many names: \emph{syntactic category}, the (rather
verbose) \emph{category of contexts and substitutions}, and the elusive
\emph{classifying category}. We endeavor to explain the meaning behind each of
these names over the course of the thesis, but for now we adopt the name most
closely describing its presentation.

\begin{definition}[The category of contexts and substitutions]\label{def:syn cat}
  Given a sketch $\mathcal{L}$, the \textbf{category of contexts and substitutions}, written \( \text{Cn}^{\times}_{\mathcal{L}}\) is presented as follows:
  \begin{outline}
    \1 The objects are the contexts of \( \mathcal{L} \), i.e., finite lists of
    distinct variables and their types.

    \1 The generating morphisms are:

    \2 Single substitutions or \emph{declarations} \( [a/x] : \Gamma \rightarrow [\Gamma, x:X] \)
    for each term \( \Gamma \vdash a : X \). The direction in the signature should be
    confusing unless you're either already an expert or a total novice to type
    theory.

    \2 Single omissions or \emph{drops} \( \hat{x} : [\Gamma, x : X] \rightarrow \Gamma \) for each
    variable $x:X$.

    \1 The laws are given by an extended version of the familiar substitution
    lemma from type theory. The following laws are added for each collection of
    terms $a,b$ and distinct variables $x$ and $y$ such that $x$ does not appear
    free in $a$ and $y$ appears free in neither $a$ or $b$:
    \begin{align*}
      % declaration follow by drop does nothing
      [a/x] ; \hat{x} &= \id \\
      % successive declarations commute up to accounting for the first
      % declaration in the body of the second
      [a/x] ; [b/y]   &= [ [ a/x ]^{*} b/y ] ; [a/x] \\
      % non-overlapping declarations and drops commute
      [a/x]; \hat{y} &= \hat{y}; [a/x] \\
      % non-overlapping drops commute
      \hat{x}; \hat{y} &= \hat{y}; \hat{x} \\
      [x/y]; \hat{x}; [y/x]; \hat{y} &= \id
    \end{align*}
  \end{outline}
  We will briefly speak to the meaning of the laws. The first law says that
  binding a variable to some term and then forgetting the variable is just the
  same as doing nothing. The second law says that successive variable
  declarations commute \emph{up to accounting for the first declaration in the
    body of the second}. The third law says that \emph{non-overlapping}
  declarations and drops commute. The fourth law says that pairs of
  non-overlapping drops commute. The last law is tricky and is easier to explain
  by passing to the substitution point-of-view. Since the change of base functor
  is contravariant, this requires considering the compositions in reverse order
  as:
  \[ \hat{y}^{*}; [y/x]^{*}; \hat{x}^{*}; [x/y]^{*} = {\id}^{*} \] Rendered
  thus, this law means that introducing a free variable $y$ to the
  context\footnote{possibly having no effect if $y$ is already present},
  followed by replacing every free occurrence of $x$ with $y$, followed by
  re-introducing $x$ as a variable in the context, and then finally replacing
  every free occurrence of $y$ with $x$ is the same as doing nothing. More
  concisely at the expense of precision, renaming a free variable in a term and
  then un-renaming it results in the same term.
\end{definition}

This category serves to allow us to define a special class of functor. In our
case, that class of functor captures what it means to produce a model of an
elementary sketch. The proof of this theorem is rather bureaucratic, but its
importance is that it teaches us that the canonical elementary language of a
category is purpose-built so that its models are precisely set-valued functors
out of the category in question.

% TODO: need to have some corollary or theorem saying how the classifying
% category acts on the clones by substitution of the term

% TODO: must include Theorem 4.2.12 from Taylor, it is essential to the
% statement of this theorem.
\subsection{Models are essentially set-valued functors out of the category of a sketch}
\begin{theorem}[The classifying category]\label{thm:classify_elem_sketch}
  Let $\mathcal{L}$ be an elementary sketch and \( \cn_{\mathcal{L}} \) the
  category it presents. Then the models of $\mathcal{L}$ correspond to functors
  $\cn_{\mathcal{L}} \rightarrow \mathfrak{Set}$.
\end{theorem}
\begin{proof}
  \( (\Rightarrow) \) Suppose we have an \( \mathcal{L}\)-model $A$. Then $A$ is an
  assignment of a set $\ceil{X}_{A}$ to each sort \( \ceil{X}\) and an
  assignment of a function \( \ceil{r}_{A} : X_{A} \rightarrow Y_{A}\) to each operation-symbol
  \( X \vdash \ceil{r}(x) : Y\) such that the laws (given by
  Theorem~\ref{thm:canonical_elementary_language}) of \( \mathcal{L} \) are preserved. These
  assignment form precisely the data of a functor

  \begin{align*}
   F_{A} &: \cn_{\mathcal{L}} \rightarrow \mathfrak{Set} \\
    X &\mapsto \ceil{X}_{A} \\
    (X \xrightarrow{r} Y) &\mapsto \ceil{r}_{A}
  \end{align*}.

  It remains to show functoriality of these assignments which follow from the
  laws of the canonical elementary language and faithfulness of the model. \\

  \( (\Leftarrow) \) Suppose we have a functor
  $F_A : \cn_{\mathcal{L}} \rightarrow \mathfrak{Set}$. We will construct a model $A$ of
  $\mathcal{L}$ from $F_{A}$ as follows: Recall from
  Theorem~\ref{thm:canonical_elementary_language} that the sorts \(\ceil{X} \)
  of the sketch $\mathcal{L}$ are precisely the objects $X$ of
  \( \cn_{ \mathcal{L}} \), and the operation symbols \( X \vdash \ceil{ f } : Y \)
  are the morphisms \( f \) of \( \cn_{\mathcal{L}}\). Now,
  \begin{enumerate}
    \item For each sort \(\ceil{X}\) we assign \( \ceil{X}_A = F_{A}(X)\).
    \item For each operation symbol \( \ceil{f} \) we assign \( \ceil{f}_{A} = F_{A}(f) \).
    \item Again by Theorem~\ref{thm:category_of_sketch}, the only laws of the
          sketch are that \(\ceil{\text{id}}(x) = x\) and
          \(\ceil{g}(\ceil{f}(x)) = \ceil{g \circ f}(x)\). According to the
          assignments in the previous two points, the first law says that
          \(F_{A}(\text{id}_{X}) = \text{id}_{\ceil{X}_{A}}\), and the second says that
          \( (F_{A} \ceil{g}) \circ (F_{A}(\ceil{f})) = F_{A} (g \circ f)\). Both are
          ensured by functoriality.
  \end{enumerate}
\end{proof}

% \subsection{Example morphisms in the syntactic category}
% A natural question for the operationally-minded reader to ask after having seen
% the definition of the syntactic category is: how does all this ornate structure
% encode terms in the calculus I'm interested in? Let us ask instead a more
% precise question: how do we represent by a substitution a term \(\Gamma \vdash t : T\)?
% For such a term, there is a canonical substitution (morphism of contexts)
% \( \Gamma \xrightarrow[]{[t/x]} \Gamma,x:X \) which ``picks'' that term in $T$. Here
% $[t/x]$ is an explicit encoding/formula for the substitution inserting $t$
% anywhere it sees $x$. The ordering of the codomain and domain here should be
% confusing, but the contravariant base change functor, which lifts this encoding
% to a real substitution \emph{operation} clarifies things; we have:
% \( [t/x]^{*} : \clone{}{\Gamma, x:X}{T} \longrightarrow \clone{}{\Gamma}{T} \). In words, the
% substitution operation takes a term of type $T$ under $\Gamma$ and an additional free
% variable $x:X$ and gives us a term of type $T$ under just $\Gamma$; we reduce our
% assumption set by filling in one of the assumptions with some concrete evidence,
% namely the (syntactic) term $t$. In the special case of a closed (syntactic)
% term $t$, we have \( [t/x]^{*} : \clone{}{x:X}{T} \longrightarrow \clone{}{\emptyset}{T}\).

\section{Algebraic theories and their algebras}
Having defined elementary sketches, which give us a way to define multi-sorted
theories, it's obvious to request the ability to define multi-input
operations\footnote{Here's a little known statistic: At least one in two readers
  of this draft will observe that the doctrine of algebraic theory can be
  rephrased in terms of operards: algebraic theories are operads for which the
  tensor product used in forming the operation domains happens to be the plain
  ol' Cartesian product~\cite{TODO: Nlab}}. Algebraic theories generalize the
doctrine of elementary sketches and allow us to do so. As we upgrade our
doctrine to allow products, many of the notions (\emph{terms, clones, syntactic
  category, etc.}) which we developed in the simplified world of elementary
sketches will come along for the ride.

\begin{definition}[Algebraic theory]\label{def:alg theory}
  A (finitary many-sorted) \textbf{algebraic theory} $\mathcal{L}$ has
  \begin{enumerate}
    \item a collection $\Sigma$ of base types or \textbf{sorts} $X$
    \item an inexhaustible collection of variables $x_{i}:X$ of each sort;
    \item a collection of \textbf{operation symbols},
          $X_{1},\dots , X_{k} \vdash r : Y$ each having an \textbf{arity}, namely a
          list of input sorts $X_{i}$, and an output sort $Y$; and
    \item a collection of \textbf{laws}, posed as equalities between different
          terms (in the sense defined before)
  \end{enumerate}
\end{definition}

The next major concept we will introduce generalizes to algebraic theories the
notion of \emph{action} or \emph{model} we saw previously for elementary
sketches. As expected, the definition will be essentially the same up to taking
some products. Before doing so, we will give an intervening example of an
algebraic theory.
\begin{example}[Algebraic theory of \emph{ring}]\label{ex:theory of ring}

  We sketch an algebraic theory encoding the familiar structure of a ring from
  abstract algebra. The presentation should look familiar (when squinting) to
  anyone with a background in abstract algebra, except that we force the
  existence of multiplicative and additive identities by requiring any model (to
  be defined!) of this theory to provide \emph{global elements}, namely
  operations out of a distinguished sort $\mathbbm{1}$.
  \begin{enumerate}
    \item Sorts: The sorts are \( \mathbbm{1}, S\). The variable collections for
          each sort are \( \set{\square} \cup \set{\square_{i}}_{i} \) and
          \( \set{s_{i}}_{i} \cup {x,y,z} \) respectively.

    \item Operations: \begin{align*}
                        \cdot &: S \times S \rightarrow S, \\
                        + &: S \times S \rightarrow S,\\
                        0 &: \mathbbm{1} \rightarrow S,\\
                        1 &: \mathbbm{1} \rightarrow S,\\
                        - &: S \rightarrow S
                      \end{align*}

    \item Laws: \begin{align*}
                  +(x,y) &= +(y,x)\\
                  +(0(\square), x) &= x\\
                  +(x, -(x)) &= 0(\square)\\
                  \cdot(x,y) &= \cdot(y,x)\\
                  \cdot(1(\square), x) &= x\\
                  \cdot(x, +(y,z)) &= +(\cdot(x,y), \cdot(x,z))
                \end{align*}
  \end{enumerate}
\end{example}

Having given the obligatory concrete example, we now have permission to proceed
with another abstract definition: that of an \emph{$\mathcal{L}$-algebra} for an
algebraic theory:

\begin{definition}[$\mathcal{L}$-algebra]\label{def:algebra}
  Given an algebraic theory $\mathcal{L}$ and a category $C$ with finite
  products (in the sense of the universal property as treated in the chapter on
  basic category theory) an \emph{$\mathcal{L}$-algebra in $C$} is comprised of
  \begin{enumerate}
    \item an object $A_{X}$ of $C$ for each sort $X$ of $\mathcal{L}$, and
    \item for each operation symbol $X_{1}, \dots , X_{k} \vdash r : Y$, an
          assignment of a map \(r_{A} : A_{X_{1}} \times \cdots \times A_{X_{k}} \rightarrow A_{Y}\) in
          $C$.
  \end{enumerate}
  such that the assignments respect the laws of $\mathcal{L}$.
\end{definition}

We are now in good shape to give an example of an algebra (in the category of
sets) for the theory of a ring given in Example~\ref{ex:theory of ring}.
\begin{example}\label{ex:integer ring}
  % TODO: maybe need to explicate the product structure here, though I think we
  % really should get that for free with an algebraic theory.
  \begin{enumerate}
    \item For the sorts, we set $A_{S} = \mathbb{Z}$ and $A_{\mathbbm{1}} = \{\star\}$
    \item For the operations, we set
    \begin{enumerate}
      \item $\cdot_A = *$ where $*$ is the ordinary multiplication of integers
      \item $+_{A} = +$ where the second plus is ordinary addition of integers
      \item $0_{A}$ to the constant function $x \mapsto 0 \in \mathbb{Z}$
      \item $1_{A}$ to the constant function $x \mapsto 1 \in \mathbb{Z}$
      \item $-_{A}$ to the function $x \mapsto -x$ taking an integer to its additive inverse
    \end{enumerate}
    \item Verifying the rest of the laws is routine after understanding how to
          verify any of them, so we demonstrate just one. We show that the $0$
          selected by the model indeed serves as the left identity of addition
          in the model.
          \begin{proof}
            \begin{align*}
              +_{A} \circ \braket{0_{A}, \id} &= (x : \{ \star \}, y : \mathbb{Z}) \mapsto 0_{A}(x) + \id(y)\\
                                          &= (x : \{ \star \}, y : \mathbb{Z}) \mapsto 0_{\mathbb{Z}} + y \\
                                          &= (x : \{ \star \}, y : \mathbb{Z}) \mapsto y\\
                                          &= \id_{\mathbbm{1}_{Z} \times S_{A}} \\
            \end{align*}

            Our proof is almost done, but we must justify that the final
            identity morphism is actually the interpretation of the variable
            (regarded as a term) $x$. This fact will be validated by results
            later in this section. In particular, Definition~\ref{def:term
              model} will give a proper treatment to the interpretation of terms
            in an algebraic theory and allow us to justify the equivalence of
            the terms $x$ and $\hat{\square}^{*} x$ by\footnote{recall from
              Definition~\ref{def:syn cat} that $\square$ is the variable we settled
              on for the sort $\mathbbm{1}$ and substitution by the hat is
              context weakening or adding the variable} way of our construction
            of the syntactic category. With the clearing of that remaining
            goal-post deferred, we have shown what is required for this law.
          \end{proof}
  \end{enumerate}
\end{example}

The reader familiar with algebra will observe that this example amounts to
verifying that the integers form a ring under the standard multiplication and
addition operations we learn in elementary school. A natural next question to
ask is how we might encode a ring homomorphism in this framework. To answer this
question, we define a more general notion:

\begin{definition}[$\mathcal{L}$-algebra homomorphism]\label{def:homomorphism}
  A \emph{homomorphism} \( A \rightarrow B\) of $\mathcal{L}$-algebras $A$ and $B$ in some
  category $\mathfrak{C}$ with finite-products is an assignment to each sort $X$
  of a $\mathfrak{C}$-morphism \( \phi_{X} : A_{X} \rightarrow B_{X}\) between the
  corresponding objects in each algebra such that diagrams of the following form
  commute:

  \[\begin{tikzcd}
      {A_{X_1}\times\cdots \times A_{X_k}} &&& {A_{X_0}} \\
      \\
      {B_{X_1}\times\cdots\times B_{X_k}} &&& {B_{X_0}}
      \arrow["{r_A}", from=1-1, to=1-4]
      \arrow["{r_B}", from=3-1, to=3-4]
      \arrow["{\phi_{X_0}}"', from=1-1, to=3-1]
      \arrow["{\phi_{X_1}\times \cdots \times \phi_{X_k}}", from=1-4, to=3-4]
    \end{tikzcd}\]

\end{definition}

\begin{remark}\label{rmk:alg_func}
  The following is an observation due to Lawvere in a paper written in his time
  teaching at Reed College \cite{lawvere_functorial_1963}. The familiarity of
  this diagram is no mistake: indeed, by analogy to
  Theorem~\ref{thm:classify_elem_sketch}, we may understand algebras as
  product-preserving functors. A mapping between algebras then is a natural
  transformation, hence the naturality diagram in
  Definition~\ref{def:homomorphism}. We will later make this analogy more
  concrete in Theorem~\ref{thm:classifying alg theory}.
\end{remark}

\begin{remark}
  Predictably, the $\mathfrak{C}$-valued algebras and homomorphisms of an
  algebraic theory $\mathcal{L}$ form a category, called
  $\mathscr{Mod}_{\mathfrak{C}}(\mathcal{L})$.
  \begin{proof}
    Per Remark~\ref{rmk:alg_func}, we consider algebras and their homomorphisms
    as functors and natural transformations respectively. The identity morphisms
    are the identity natural transformations whose component morphisms are the
    identities of $\mathfrak{C}$. Composition of natural transformations is
    given by composition of their component morphisms, hence we may out-source
    the associativity condition to that guaranteed by the categorical structure
    of $\mathfrak{C}$.
  \end{proof}

\end{remark}

Most questions in type theory are concerned with the \emph{terms} of the theory
at hand. Normalization theorems talk about the accessibility (under some
reduction relation) of a certain class of terms from any arbitrary term.
Canonicity, a stronger property implying normalization, talks about the
accessibility of another more strict class of terms from arbitrary start terms.
These are but two examples of a broad spectrum of properties one might desire of
the terms of a theory. Considering the primacy of term properties in type
theory, it is rather strange that the notion of semantics we have built so far
makes no commentary on terms besides the action on the clones given in
Theorem~\ref{thm:clone model}. Our models so far have only given meaning to the
individual \emph{sorts} (types) and individual \emph{operation symbols}
(constructors) of the theory considered. In fact, this is enough: our models
extend canonically to contexts and substitutions and thus give meaning to terms.

\DeclarePairedDelimiter{\sem}{\llbracket}{\rrbracket}

\begin{definition}[Extending a model to terms]\label{def:term model}
  Let $A$ be an $\mathcal{L}$-algebra in a category $\mathfrak{C}$. This algebra
  extends canonically to an interpretation $\sem{-}$ of contexts by the
  following definition recursive in the structure of contexts:
  \begin{align}
    \label{eq:contexts interp}
    \sem{\varnothing} &= \mathbbm{1}_{C} \\
    \sem{\Gamma, x : X} &= \sem{\Gamma} \times A_{X}
  \end{align}
  The (overly) careful reader will complain that $\mathfrak{C}$ doesn't
  necessarily feature a terminal object, but it turns out that a terminal object
  is guaranteed\footnote{as the nullary finite product} by the finite product
  closure we imposed on $\mathfrak{C}$ in our definition of algebras. We are
  good to go.

  Recalling more from the definition of an algebra, we know that $A$ gives
  meaning to each operation symbol \( Y_{1},\dots , Y_{k} \vdash r : Z \) as a
  morphism \( r_{A} : A_{Y_{1}} \times \cdots \times A_{Y_{k}} \rightarrow A_{Z} \) and gives meaning to
  each constant \( c : Z \) by a morphism \( 1_{\mathfrak{C}} \rightarrow A_{Z} \). We can
  extend this uniquely to arbitrary terms in the context
  \( \Gamma \equiv \sem{x_{1} : X_{1}, \dots , x_{n} : X_{n}} \) by the following
  recursive definition:
  \begin{align}
    \label{eq:term interp}
    \sem{x_{i}} &: \sem{\Gamma} \equiv A_{X_{1}} \times \cdots \times A_{X_{n}} \xrightarrow{\pi_{i}} A_{X_{i}} \\
    \sem{c} &: \sem{\Gamma} \xrightarrow{<_{!}} \mathbbm{1}_{C} \xrightarrow{c_{A}} A_{Z} \\
    \sem{r(u_{1}, \dots , u_{k})} &: \sem{\Gamma} \xrightarrow{\braket{\sem{u_{1}}, \dots, \sem{u_{k}}}} A_{Y_{1}} \times \cdots \times A_{Y_{k}} \xrightarrow{r_{A}} A_{Z}
  \end{align}
  where the $\sem{u_{i}}$ are the interpretations of the sub-expressions of the
  expression in the final line, $\pi_{i}$ is the $i$th projection guaranteed to us
  by the universal property of products, and $<_{!}$ is the unique map into the
  terminal object. The angle bracket notion is used to express the product
  functor's action on morphisms in $\mathfrak{C}$. For clarity, we write out
  explicitly the composites for the reader:
  \begin{align*}
    \sem{x_{i}} &\equiv \pi_{i} \\
    \sem{c} &\equiv c_{A } \circ <_{!} \\
    \sem{r(u_{1}, \dots , u_{k})} &\equiv r_{A} \circ \braket{\sem{u_{1}}, \dots,\sem{u_{k}}}
  \end{align*}
\end{definition}

\begin{theorem}[The classifying category of an algebraic
  theory]\label{thm:classifying alg theory}
  Let \( \mathcal{L} \) be an algebraic theory. Then
  \begin{enumerate}
    \item $\cn_{\mathcal{L}}^{\times}$ has finite products and an
          $\mathcal{L}$-algebra.
    \item Let $\mathfrak{C}$ be another category with a choice of finite
          products and an $\mathcal{L}$-algebra. Then the functor
          $\sem{-} : \cn_{\mathcal{L}}^{\times} \rightarrow \mathfrak{C}$ preserves finite
          products and the $\mathcal{L}$-algebra, and is the unique such
          functor.
    \item Any functor \( \cn_{\mathcal{L}}^{\times} \rightarrow C \) which preserves finite
          products also preserves the $\mathcal{L}$-algebra.
  \end{enumerate}
\end{theorem}
\begin{proof}\,\\
  \begin{enumerate}
    \item We first show that the syntactic category has finite products. Recall
    that the objects of the syntactic category are variable contexts \([x : X, y
    : Y, z : Z, \dots]\). For any other context \( [t : T, u : U, v : V, \dots]
    \) we have the product \[ [x : X, y : Y, z : Z, \dots] \times [t : T, u : U,
    v : V] = [x : X, y : Y, z : Z, \dots, t : T, u : U, v : V, \dots]\] That
    is, products are given by concatenation of contexts. Now the model is given
    as follows:
    \begin{enumerate}
      \item The sorts $X$ of $\mathcal{L}$ are interpreted as single variable
      contexts $[x:X] \in \ob C$ where the variable $x$ is arbitrary.
      \item The operation symbols \( X_1, X_2, \dots \vdash r : Y \) of
      $\mathcal{L}$ are interpreted as substitutions \( [r(x_1, x_2, \dots)/y] :
      [x_1:X_1, x_2:X_2,\dots] \rightarrow [y : Y]\) 
    \end{enumerate}
    \item The functor promised is precisely the one defined by
          Definition~\ref{def:term model}. TODO: we still need to verify the
          uniqueness of this functor, which Taylor himself never demonstrates.
          \item This result demands a full proof, which isn't given in Taylor.
          \begin{proof}
            Suppose we have a functor $F : \cn_{\mathcal{L}}^{\times} \rightarrow \mathfrak{C}$
            which preserves products. We will show that it preserves the
            $\mathcal{L}$-model, in particular, that it takes the interpretation
            in $\cn_{\mathcal{L}}^{\times}$ of any context $\Gamma$ to the interpretation
            of $\Gamma$ in $\mathfrak{C}$. TODO.

            \textbf{Note}: Taylor claims the proof of this is given
            in~\cite{lawvere_functorial_1963}, but I am (so far, I haven't tried
            too long) unable to identify the result in that paper, probably
            because Lawvere's formulation of algebraic theories is very
            different from Taylor's. I plan to tie up this loose end sometime
            soon.
          \end{proof}
  \end{enumerate}
\end{proof}
\chapter{Functorial semantics of the simply typed lambda calculus in cartesian closed categories}\label{chapter:stlc}
\epigraph{``Eeny, meeny, miny, moe''}{Alonzo Church (Allegedly, on his choice of
  $\lambda$ as the name for his calculus.)}

This chapter exploits the heavy machinery developed in the previous chapter to
give meaning, in specially structured categories, to the types and terms of the
simply typed lambda calculus. In particular, we will present the lambda calculus
as an \emph{algebraic theory} and leverage our existing theory to give an
interpretation of lambda terms in any \emph{cartesian closed} category with an
interpretation of the base types. We will begin by presenting the term language
and type system for the calculus under consideration.

\section{The simply typed lambda calculus}
We'll work with the simply typed lambda calculus with a boolean base type. We
will not dwell on the details of standard aspects of this development and refer
the reader to the standard references (\cite{pierce_types_2002},
\cite{harper_practical_2016}) for the full story.


\begin{definition}[Types]\label{def:stlc_types}
  The types \( \types \) of the simply typed lambda calculus are
  generated by the following grammar:
  \[
    \tau \Coloneqq \termob \mid \tau_{1} \rightarrow \tau_{2} \mid \tau_{1} * \tau_{2}
  \]
\end{definition}

\begin{definition}[Terms]
  The terms of the simply typed lambda calculus (with booleans) are generated by the
  following grammar:
  \[
    t \Coloneq x \mid () \mid \pi_{1} t \mid \pi_{2} t \mid (t_{1}, t_{2}) \mid t_{1} t_{2} \mid \abstr{x}{\tau}{t}
  \]
  where the variables $x$ are drawn from a countably infinite set \( V \).
\end{definition}

The typing rules are given as follows:
\begin{definition}[Typing rules]\label{def:stlc_rules}
    \begin{mathpar}
    \inferrule[]{ \Gamma \vdash t : \tau_1 * \tau_2 }{ \Gamma \vdash \pi_{i} t: \tau_{i} } \and \inferrule{ \Gamma \vdash t_{i} : \tau_{i} }{(\tau_1,\tau_{2}) : \tau_{1} * \tau_{2}}\\
    \inferrule{ \Gamma \vdash t_{1} : \tau' \rightarrow \tau  \\  \Gamma \vdash t_{2} : \tau' }{ \Gamma \vdash t_{1} t_{2} : \tau } \and \inferrule{ \Gamma,x:\tau' \vdash t : \tau}{ \Gamma \vdash \abstr{x}{\tau'}{t} : \tau' \rightarrow \tau}\\
    \inferrule*[Right={ (x:\tau) \in \Gamma }]{ }{ \Gamma \vdash x : \tau }\\
    \inferrule{ }{ \Gamma \vdash () : \termob }
  \end{mathpar}
\end{definition}

\section{Lambda theories, beta-eta rules, and cartesian closed categories}
We now define a notion which mediates between full-cartesian closed structure
and having lambda abstraction at all. Our definition comes from Taylor
\cite{taylor_practical_1999}.

\begin{definition}[Raw cartesian closed structure]
  Let \( \mathfrak{C} \) be a category with a specified terminal object
  \( \termob \) and specific products together product projections. We say that
  \( \mathfrak{C} \) is \emph{raw cartesian closed} or \emph{has raw cartesian
    closed structure} if we have the following for each pair of objects
  \( X, Y \) of \( \mathfrak{C} \):
  \begin{enumerate}
    \item An object \( Y^{X} \)
    \item An morphism, \emph{application}, \( \evsig{X}{Y} \) and
    \item For each object \( \Gamma \), a function of hom-sets
          \( \lambda_{\Gamma, X, Y} : \mathfrak{C}(\Gamma \times X, Y) \rightarrow \mathfrak{C}(\Gamma, Y^{X})\) obeying
          the naturality law:
          \[
            \lambda_{\Gamma, X, Y} ( \mathfrak{p} \circ (\mathfrak{u} \times \id_{X})) = \lambda_{\Gamma, X, Y}(\mathfrak{p}) \circ \mathfrak{u}
          \]
          for each \( \mathfrak{u} : \Gamma \rightarrow \Delta \) and
          \( \mathfrak{p} : \Delta \times X \rightarrow Y \).
  \end{enumerate}
\end{definition}

Most sources define the following only by \emph{context clues}, which is a
technical term meaning that they don't define it at all. We give an explicit
characterization of \emph{lambda theories}:

\begin{definition}[Lambda theory]
  An algebraic theory $\mathcal{L}$ is a \emph{lambda theory} if its classifying
  category \( \cnprod \) has raw cartesian closed structure.
\end{definition}

\begin{definition}[Beta-eta rules]
  A lambda-theory $\mathcal{L}$ satisfies the \emph{$\beta-\eta$ rules} if for all
  \( \mathfrak{p} \in \cn_{\mathcal{L}}(\Gamma \times X,Y) \) we have
  \begin{align*}
    \ev{X}{Y} \circ (\lambda_{\Gamma,X,Y}(\mathfrak{p}) \times \id_{X}) &= \mathfrak{p} && (\beta) \\
    \lambda_{Y^{X},X,Y}(\ev{X}{Y}) &= \id_{Y^{X}} && (\eta)\\
  \end{align*}
\end{definition}

These deserve some commentary. The beta rule says that application of an
abstracted body $\mathfrak{p}$ to the identity gives you back the body you
started with: the beta rule forces that application of lambda expressions does
nothing more than substitute for the abstracted variable. TODO: explain eta.

We now define a notion more well-known outside of computer science. Cartesian
closed structure endows a category with the ability to take products and
function spaces over its objects in a suitable fashion. It will turn out that
this familiar form is equivalent to the combination of raw cartesian closed
structure and beta-eta rules.
\begin{definition}[Cartesian closed structure]
  A category \( \mathfrak{C} \) is \emph{cartesian closed} if it has all
  products and exponentials.
\end{definition}

The category \( \catset \) is the prototypical cartesian closed category whose
products are the usual cartesian products of sets and whose exponentials are
function spaces: for sets $X$ and $Y$, \( Y^{X} = \{ \textrm{functions
} f \mid \textrm{dom}(f) = X \wedge \textrm{cod}(f) = Y \}\). Another good source of
example cartesian closed categories is topos theory. All elementary toposes,
including categories of presheaves, are cartesian closed
(\cite{leinster_informal_2011}.) It turns out that all of these examples of
cartesian closed categories can also be characterized as the classifying
categories of lambda theories satisfying the beta-eta rules.

\begin{theorem}[Finite-product category + raw CCS + beta-eta $\iff$ cartesian closed]\label{thm:rawbetaetaisccs}
  Let \( \mathfrak{C} \) be a category. Then \( \mathfrak{C}\) is cartesian
  closed if and only if \( \mathfrak{C} \) has finite products, a specified
  terminal object, and both is raw cartesian closed and satisfies the beta-eta
  laws.
\end{theorem}
\begin{proof}
  TODO
\end{proof}

\subsection{An algebraic theory of the lambda calculus}

Finally, we will present the lambda calculus as a series of algebraic theories,
each of which are identical except for the equations they admit. These theories
will correspond to different instances of the lambda calculus with more or less
terms identified according to the usual \( \beta\eta\alpha \) conversion rules.

\begin{definition}[Algebraic theory of the lambda calculus]
  The \emph{$\alpha$-lambda calculus} is presented as the following algebraic theory:
  \begin{enumerate}
    \item Sorts: We define the sorts \( \Sigma_{\lambda}\) to be the set
    \( \types \) given in Definition \ref{def:stlc_types}.
    \item Variables: The variables are drawn from some countably infinite set
          $V$ as in the definition of terms.
    \item We define the following operation symbols for each
          \(\tau_{1},\tau_{2},\tau,\tau' \in \Sigma_{\lambda}\):
          \begin{align*}
            t : \tau_{1} * \tau_{2} &\vdash \pi_{1}(t) : \tau_{1} \\
            t : \tau_{1} * \tau_{2} &\vdash \pi_{2}(t) : \tau_{2} \\
            [t_{1} : \tau_{1}, t_{2} : \tau_{2}] &\vdash (t_{1},t_{2}) : \tau_{1} * \tau_{2} \\
            \\
            [t : \tau' \rightarrow \tau , t' : \tau'] &\vdash t\, t' : \tau \\\\
            &\vdash () : \termob\\
          \end{align*}
          The reader will note that we have not yet added an operation symbol
          for lambda abstraction. This requires careful consideration, because
          lambda abstraction is not really an operation symbol but rather a
          family of operation symbols defined mutually with the others. For each
          term \( \Gamma, x:\tau' \vdash t : \tau \), we add a new operation symbol
         \begin{align*}
           \Gamma &\vdash (\lambda (x:\tau').\, t)(\overrightarrow{\gamma}) : \tau && \text{(where $\overrightarrow{\gamma}$ is the list of variables comprising $\Gamma$)}
         \end{align*}
          The operation symbols are the least (TODO: does this even make sense)
          set closed under taking abstractions in this way.
    \item The equations are only those of the $\alpha$-rule which says that terms can
          be identified up to renamings of their bound variables. We notably do
          not include the $\beta\eta$-rules in this version.
          \begin{align*}
            \alphalaw && (\alpha)
          \end{align*}
          defined for each operation symbol \( f : Y^{X}\) and terms
          \( \Gamma, x : X \vdash t : \tau \) and \( \Gamma \vdash t' : X\).
  \end{enumerate}
\end{definition}

\begin{theorem}[$\alpha$-lambda calculus is raw cartesian closed ]
  The $\alpha$-lambda calculus is raw cartesian closed
\end{theorem}
\begin{proof}
  TODO see Taylor
\end{proof}

\begin{definition}[Lambda calculus]\label{def:alpha_beta_eta_theory}
  The lambda calculus, or the $\alpha\beta\eta$-lambda calculus is defined as the algebraic
  theory of the $\alpha$-lambda calculus with the following additional equational
  laws:
  \begin{align*}
    \betalaw && (\beta)\\
    \etalaw && (\eta)\\
  \end{align*}
\end{definition}

\begin{theorem}[Lambda calculus is a lambda theory with beta-eta]
\end{theorem}

\begin{corollary}[The classifying category of the lambda calculus is cartesian closed]
  Immediate by the previous result and Theorem~\ref{thm:rawbetaetaisccs}.
\end{corollary}

\begin{corollary}[$\lambda$-algebras are diagrams in cartesian closed categories]
  Immediate by the previous result and Theorem~\ref{thm:classifying alg theory}.
\end{corollary}

\begin{corollary}[An interpretation of base types in a CCC gives rise to an interpretation of $\lambda$-terms]
\end{corollary}

This final result will prove important in \ref{chapter:gluing}

\chapter{Normalization by evaluation: the classical perspective}
In this chapter, we outline the technique of \emph{normalization by evaluation}
which exploits an existing programming language evaluator to produce a
normalization function for the \emph{open terms} of some other language. Our
intent is merely to communicate the ideas involved with a view to drawing
analogies to normalization by evaluation in our later discussion of gluing. In
light of this, we describe the technique in full detail but omit all proofs of
correctness (in the literature called ``soundness'') % TODO: explain what
                                                     % soundness is here;
                                                     % mention other nbe
                                                     % desiderata?
The chapter will follow our OCaml implementation of normalization by evaluation
for G\"odel's System T. Our implementation was inspired by the habilitation of
Andreas Abel and the Wikipedia page on normalization by evaluation written by a
number of authors.

\begin{verbatim}
open Core

type ty = Arrow of ty * ty
        | Prod of ty * ty
        | Nat [@@deriving sexp]

type var = string [@@deriving sexp]

let cur : int ref = ref 0

let fresh () : var = let res = Printf.sprintf "var%d" !cur in
                     cur := !cur + 1;
                     res

type syn = Lam of var * ty * syn
         | App of syn * syn

         | Pair of syn * syn
         | P1 of syn
         | P2 of syn

         | Zero
         | Succ of syn
         | Rec of ty * syn * syn * syn (* rec : forall (T: ty), T -> (N -> T -> T) -> N -> T *)

         | Var of var [@@deriving sexp]

(* Note: There are no elimination forms in the semantics; they are represented
   as syntax through the SYN embedding. *)
type sem = LAM of (sem -> sem)
         | PAIR of sem * sem
         | SYN of syn
[@@deriving sexp]

(* reflect is a type-indexed family of functions taking the syntax into the
   semantics *)
let rec reflect (tau : ty) : syn -> sem =
  fun t ->
  match tau with
  | Arrow (a, b) ->
    LAM (fun s -> reflect b (App (t, (reify a s)) ))
  | Prod (a, b) ->
    PAIR ((reflect a (P1 t), (reflect b (P1 t))))
  | Nat ->
    SYN t

and reify (tau : ty) : sem -> syn =
  fun t ->
  match (t, tau) with
  | (LAM s, Arrow (a, b)) ->
    let x = fresh () in
    Lam (x, tau, reify b (s (reflect a (Var x))))
  | (PAIR (l, r), Prod(a,b)) ->
    Pair (reify a l, reify b r)
  | (SYN b, _) ->
    b
  | _ ->
    raise (Failure (Printf.sprintf "Reification failed on (%s : %s)"
                      ([%sexp_of : sem] t |> Sexp.to_string)
                      ([%sexp_of: ty] tau |> Sexp.to_string)))


let rec metarec (tau : ty) (z : 'a) (s : syn -> 'a -> 'a) : syn -> 'a =
  fun n ->
  match n with
  | Zero -> z
  | Succ n ->
    s n (metarec tau z s n)
  | u ->
    let v_z = reify tau z in
    let v_s = reify (Arrow(Nat, (Arrow (tau, tau)))) (LAM (fun n -> match n with
                                                            | SYN n -> LAM(s n)
                                                            | _ -> raise (Failure "in metarec"))) in
    reflect tau (Rec (tau, v_z, v_s, u))

type context = (var * ty) list

(* A valuation is a list semantic terms to be interpreted as an assignment of
   terms to variables in an ordered context *)
type valuation = (var * sem) list


(* we assume that a bad lookup is never performed; this will end up being the
   case as long as we only take the meaning in the valuation generated by the
   context closing a well-typed term. *)
let lookup (x : var) (rho : valuation) : sem =
  List.rev (List.filter ~f:(fun entry -> String.equal (fst entry) x) rho)
  |> fun l -> List.nth_exn l 0
  |> snd

(* Given a context gamma, produces a valuation of reflected variables *)
let reflect_ctx (gamma : context) : valuation =
  List.map ~f:(fun (x,tau) -> (x, reflect tau (Var x))) gamma

(* interprets into the semantics an open term t with respect to a valuation rho
   which closes it *)
let rec interp (t : syn) (rho : valuation): sem =
  match t with
  | Var x ->
    lookup x rho
  | Lam(x, _, b) ->
    LAM (fun s -> interp b (List.append rho [(x,s)]))
  | App(e1, e2) ->
    let LAM e1f = interp e1 rho in
    e1f (interp e2 rho)
  | Pair(e1, e2) ->
    PAIR(interp e1 rho, interp e2 rho)
  | P1 e ->

    let PAIR (l,_) = interp e rho in
    l
  | P2 e ->
    let PAIR (_,r) = interp e rho in
    r
  | Zero -> SYN Zero
  | Succ n ->
    SYN (Succ n)
  | Rec(tau, z, s, n) ->
    let LAM si = interp s rho in (* s : nat -> A -> A *)
    let zi = interp z rho in
    let SYN ni = interp n rho in
    metarec tau zi (fun m -> let LAM(f) = si (SYN m) in f) ni
    [@@warning "-8"]
(* the above incomplete matches are irrefutable on well-typed terms t *)

let nbe (gamma : context) (tau : ty) : syn -> syn =
  fun t -> interp t (reflect_ctx gamma) |> reify tau

(* EXAMPLES:
    nbe [("y", Nat); ("z", Nat)] Nat (App (Lam("x", Nat, Var("y")), Var ("z")));;
    - : syn = Var "y"

   nbe [] Nat (App ((Lam ("z", Nat, (Rec(Nat, Zero, Lam("x",Nat,Lam("y",Nat,(Var "x"))), (Var "z"))))), (Succ Zero)));;
   - : syn = Zero*)
\end{verbatim}

\chapter{Normalization by gluing}\label{chapter:gluing}
\epigraph{You, you were like glue\\
holding each of us together\\
I slept through July\\
while you made lines in the heather}{Fleet Foxes, ``Lorelai''}

This chapter will consider the normalization problem for the simply typed lambda
calculus using all of the magic technology we've developed so far. Normalization
comes in both weak and strong flavors, but both are properties of a formal
system together with a \emph{reduction} relation, say, \( - \rightarrow = \). By a
\emph{normal form} we mean a term $t$ for which there is no other $t'$ such that
\( t \rightarrow t' \). Writing \( - \rightarrow^{*} = \) for the least transitive, reflexive
closure of this relation, we say the reduction system enjoys \emph{weak
  normalization} if for any well-typed term \( e \), there exists a normal form
\( n \) such that \( e \red n\). A reduction system enjoying \emph{Strong
  normalization} is one for which \emph{every} reduction sequence ends in a
normal term. \emph{Metatheorems} of this kind tend to resist standard techniques
like straight-forward induction over the types of the lambda calculus. Instead,
metatheoreticians resort to the \emph{occult} technique of logical relations.
The method of logical relations is, broadly speaking, opaque even to experienced
practitioners. The construction is easy to use in simple settings like that of
the simply-typed lambda calculus (see \cite{pierce_types_2002}) but becomes
devilishly complicated when working with more complex lambda calculi.

The method of \emph{Artin gluing}, torn from the topos theorist's cookbook, is a
more transparent encoding of the mechanics of logical relations. Where the
method of logical relations is ad-hoc and mysterious, gluing regularizes the
thought involved and makes the choices involved in proofs by logical relations
completely automatic. The \emph{scone} or \emph{Sierpinski cone} is a famous
instance of the gluing construction used in and outside of type theory. The
\emph{scone} is not suited to our particular problem of \emph{(open)
  normalization} however, as the scone is generally concerned with properties of
\emph{closed terms} with no free variables, whereas our construction will apply
to terms in any context.
\section{Variable-arity Kripke relations}
TODO
\section{The comma construction and friends}
This section introduces a general construction that will, among other things,
allow us to define the gluing construction. As hinted at before, gluing is just
a special case of the comma. The idea of the comma is to glob some extra data to
the objects of a category, and has a notion of an
object-with-extra-data-morphism which preserves the attached data. This
intuition perhaps underlies the name for the gluing construction which is a
special case of the comma.

\begin{definition}[Comma category]
  Let $E,D,C$ be categories and $F: D \rightarrow C \leftarrow E : G$ be a pair of functors sharing
  their codomain $C$. The comma category \( F \downarrow G \) has as its
  \begin{enumerate}
    \item Objects: triples \( (d : D, Fd \xrightarrow{f} Ge, e : E) \)
    \item Morphisms: arrows $(h,k) : (d, f, e) \rightarrow (d', f', e')$ are pairs of
          $D$ and $E$-morphisms \(h : d \rightarrow d', k : e \rightarrow e'\) making the following
          diagram commute:
          \[
            \begin{tikzcd}
              Fd \arrow{r}{Fh} \arrow{d}[swap]{f} & Fd' \arrow{d}{f'} \\
              Ge \arrow{r}[swap]{Gk} & Ge'\\
            \end{tikzcd}
          \]
  \end{enumerate}
\end{definition}

\subsection{An easy comma: the category of renamings}
The category of renamings is something like a less proof-relevant version of the
category of contexts and substitutions in the following sense: if there exists a
substitution relating two contexts in syntactic category, then there exists a
renaming relating the same contexts. In this sense, renamings allow us to track
changes in context \emph{due to a substitution} without actually using
substitutions which, because substitutions are identified up to computation, are
problematic in a development requiring distinguishing between terms at various
stages of reduction (e.g. distinguishing between a term and its normal form.)
The category of renamings allows us to define the presheaves we need while not
losing track of how contexts evolve by substitution. These two points are
precisely the desiderata satisfied by the category of renamings. We define the
category and at the same time explain what its morphisms are in terms of the
more familiar notion of substitution:

The category of renamings has a nice presentation as a comma category.
\begin{definition}[Category of renamings]
  Recall \( V \) the countably infinite set of variables and \( \types \) the
  set of all types in the simply typed lambda calculus from our early
  definitions in Chapter~\ref{chapter:stlc}. Let \( \fin \) be the category
  whose objects are finite subsets of \( V \) and whose morphisms are all
  functions between the underlying sets. Let \( \mathbb{T} : \fin \rightarrow \catset \)
  be the functor which is constantly \( \types \) on objects and constantly
  \( \id_{\types}\) on morphisms. Let \( U : \fin \rightarrow \catset \) be the forgetful
  functor taking finite variable sets to their underlying sets and functions to
  functions. Now by the \emph{category of renamings} we mean the \emph{opposite
    category} of the comma \( U \downarrow \mathbb{T} \) whose
  \begin{itemize}
    \item Objects are \emph{pairs} \( (V : \fin, \Gamma : V \rightarrow \types) \), i.e.,
    finite variable list together with an assignments of types to a each
    variable. Note that we elide the final entry of the triple of the
    comma objects, since it adds no extra information. These objects are
    precisely the contexts of the familiar classifying category.
    \item Morphisms of contexts \( (V , \Gamma) \rightarrow (V', \Gamma')\) are functions
    \( \rho : V \rightarrow V' \) making the following diagram commute:
    \[
      \begin{tikzcd}
        V \arrow{d}[swap]{\Gamma} \arrow{r}{\rho} & V' \arrow{d}{\Gamma'} \\
        \types \arrow{r}[swap]{\id_{\types}} & \types\\
      \end{tikzcd}
    \]
    The reason the comma morphisms are single functions and not pairs is
    that the second function would not communicate any data, it would just
    be taken by \( \mathbb{T}\) to the identity no matter what it is. We
    now unpack this means. The functions \( \rho \) are \emph{type-preserving
      renamings}: for each variable \( x \in V\), we have that
    \( \Gamma'(\rho x) = \Gamma(x)\). In particular, this restricts \( \rho \) to the
    following classes of morphisms in the classifying category:
    substitutions of variables for variables of the same type, context
    extension with new variables, and all compositions of these.
  \end{itemize}

  We write \( \ren = (U \downarrow \mathbb{T})^{\textrm{op}}\) for the category of
  renamings.
\end{definition}

\begin{remark}\label{rmk:reninclusioncl}
  There is an obvious inclusion \( \iota : \ren \rightarrow \cl \) which takes contexts to
  contexts and casts renamings as change-of-variable substitutions. When going
  between \( \ren \) and \( \cl \), we will take liberty to implicitly insert
  this coercion as needed without further warning. It turns out that this
  inclusion is \emph{faithful} and thus witnesses \( \ren \) as a
  \emph{subcategory} of the syntactic category.
\end{remark}

\subsection{A harder example: the gluing category; or, the category of proof-relevant Ren-Kripke relations over types}
The gluing category is an instance of the comma construction which will star as
the primary semantic domain in our development. To define it, we first need to
define a functor which, in a loose sense that will be explained in due course,
defines \( \ren \)-presheaves of \emph{open} terms.
\subsubsection{The relative hom functor}
Every functor \( \varsigma : \mathcal{R} \rightarrow \mathcal{S} \) induces the following
situation:

% https://q.uiver.app/?q=WzAsNSxbMCwwLCJcXG1hdGhjYWx7Un0iXSxbMiwwLCJcXG1hdGhmcmFre1NldH1ee1xcbWF0aGNhbHtSfV5cXHRleHRybXtvcH19Il0sWzAsMSwiXFxtYXRoY2Fse1N9Il0sWzIsMSwiXFxtYXRoZnJha3tTZXR9XntcXG1hdGhjYWx7U31eXFx0ZXh0cm17b3B9fSJdLFsxLDBdLFswLDIsIlxcdmFyc2lnbWEiLDJdLFsyLDMsIuOCiCIsMix7InN0eWxlIjp7InRhaWwiOnsibmFtZSI6Imhvb2siLCJzaWRlIjoiYm90dG9tIn19fV0sWzIsMSwiXFxicmFrZXR7XFx2YXJzaWdtYX0iLDAseyJzdHlsZSI6eyJib2R5Ijp7Im5hbWUiOiJkYXNoZWQifX19XSxbMywxLCJcXHZhcnNpZ21hXioiLDJdXQ==
\[\begin{tikzcd}
	{\mathcal{R}} & {} & {\mathfrak{Set}^{\mathcal{R}^\textrm{op}}} \\
	{\mathcal{S}} && {\mathfrak{Set}^{\mathcal{S}^\textrm{op}}}
	\arrow["\varsigma"', from=1-1, to=2-1]
	\arrow["{よ}"', hook', from=2-1, to=2-3]
	\arrow["{\braket{\varsigma}}", dashed, from=2-1, to=1-3]
	\arrow["{\varsigma^*}"', from=2-3, to=1-3]
\end{tikzcd}\]

That is, we get a functor
\[
  \braket{\varsigma} : \mathcal{S} \rightarrow \mathfrak{Set}^{\mathcal{R}^{\textrm{op}}}
\]
by adjusting the Yoneda embedding into the category of
$\mathcal{S}$-presheaves. In particular, specializing to the case of the
inclusion \( \iota : \ren \rightarrow \cl \) of Remark~\ref{rmk:reninclusioncl} gives us a
functor
\begin{align*}
  \mathfrak{Tm} : \cl &\rightarrow \renhat \\
  \Delta &\mapsto \cl(\iota(-), \Delta)\\
\end{align*}
which can be construed as taking a syntactic context to a presheaf of open
terms. This is a confusing idea at first, and it helps to consider the simple
cases to understand it. Consider any singleton context \( \tau : \cl \). Then $\tm$
takes $\tau$ to the presheaf \( \cl(-, \tau)\) which takes any renaming context
\( \Gamma \) to \( \cl(\Gamma, \tau)\). Recalling the definition of the syntactic category
and its generating morphisms, the latter set comprises the terms of type \( \tau \)
closed under $\Gamma$, represented as single substitutions \( [t/x] : \Gamma \rightarrow \tau \).
Generalizing to multivariable target contexts \( \Delta \) gives presheaves of
\emph{lists} of open terms of the types in $\Delta$.

\subsubsection{Gluing syntax to semantics along the relative hom functor}
We at last define the \emph{gluing category} as the comma of the category of
renamings along the relative hom functor just defined.

\begin{definition}[The gluing category]
  The gluing category \( \gl \) is defined as the comma \( \renhat \downarrow \tm \).
  Explicitly, its objects are triples
  \( D : \renhat, q : D \Rightarrow \tm(\Delta), \Delta : \cl \). The objects of the gluing category
  are \emph{proof relevant logical predicates}, in a sense that will be more
  clear after the next subsection. Following the definition of the comma
  construction, the morphisms \( (D, q_{\Delta}, \Delta) \rightarrow (D', q_{\Delta'}, \Delta') \) are pairs
  $(d : D \rightarrow D', \delta: \cl[\Delta', \Delta])$ are pairs of a $\renhat$ natural transformation
  and a substitution making the following diagram commute:
  % https://q.uiver.app/?q=WzAsNCxbMCwwLCJEIl0sWzIsMCwiRCciXSxbMCwyLCJcXG1hdGhmcmFre1RtfShcXERlbHRhKSJdLFsyLDIsIlxcbWF0aGZyYWt7VG19KFxcRGVsdGEnKSJdLFswLDEsImQiXSxbMiwzLCJcXG1hdGhmcmFre1RtfShcXGRlbHRhKSJdLFswLDIsInFfe1xcRGVsdGF9IiwyXSxbMSwzLCJxX3tcXERlbHRhJ30iXV0=
  \[\begin{tikzcd}
      D && {D'} \\
      \\
      {\mathfrak{Tm}(\Delta)} && {\mathfrak{Tm}(\Delta')}
      \arrow["d", from=1-1, to=1-3]
      \arrow["{\mathfrak{Tm}(\delta)}", from=3-1, to=3-3]
      \arrow["{q_{\Delta}}"', from=1-1, to=3-1]
      \arrow["{q_{\Delta'}}", from=1-3, to=3-3]
    \end{tikzcd}\]
\end{definition}

We will better understand what all this means after understanding how the gluing
category subsumes the notion of variable-arity Kripke relations.

\subsubsection{The subcategory of (ordinary) variable-arity Kripke relations}
We can recover ordinary, proof-\emph{irrelevant} variable-arity Kripke relations
as a subcategory of the gluing category. In particular, ordinary variable-arity
Kripke relations arise as those objects
\( (D : \renhat, q : D \Longrightarrow \tm (\Delta), \Delta : \cl) \) of the gluing category whose
quotient map $q$ is a component-wise monomorphism; i.e., for each
\( \Gamma \in \ren \), we have that \( q_{\Gamma} : D(\Gamma) \rightarrowtail \tm (\Delta)(\Gamma) \) is a monomorphism.
Here's why. Recalling the definition of $\ren$-Kripke relations over $\tau \in \cl$,
we need to find in these data a $\ren$-indexed family \( \{ R_{\Gamma}\}_{\Gamma \in \ren}\)
of sets of $\cl$-morphisms into \( \tau \) subject to the following relative
monotonicity condition: for any renaming \( \rho : \Gamma' \rightarrow \Gamma \), if \( t : \Gamma \rightarrow \tau \) is
in \( R_{\Gamma}\), then we have that \( t \circ \rho : \Gamma' \rightarrow \tau \) is in \( R_{\Gamma'}\). Looking
again to our proposed Kripke predicate objects of the gluing category, we can
see that the presheaf \( R \) together with the natural mono \( q \) define for
each \( \Gamma \) a subset\footnote{this result is elementary for $\catset$, but also
  holds for any \emph{topos} modulo its notion of subobjects
  (\cite{leinster_informal_2011})} of the substitutions \( \Gamma \rightarrow \tau \). It is
tempting to dismiss the naturality of $q$ as bureaucracy; but naturality turns
out to be essential to recovering the relative monotonicity condition. To see
why this recovers what we had before, let us look at the naturality diagram of
\( q \):

  \[\begin{tikzcd}
      {R (\Gamma)} &&& {\tm(\Delta) (\Gamma)} & t \\
      \\
      {R (\Gamma')} &&& {\tm(\Delta) (\Gamma')} & {t \circ \rho}
      \arrow["{q_{\Gamma}}", from=1-1, to=1-4, rightarrowtail]
      \arrow["{q_{\Gamma'}}", from=3-1, to=3-4, rightarrowtail]
      \arrow["{R (\rho)}"', from=1-1, to=3-1]
      \arrow["{\tm(\Delta) (\rho)}", from=1-4, to=3-4]
      \arrow[from=1-5, to=3-5, mapsto]
    \end{tikzcd}\]

  As mentioned before, because they are monos we may identify the component
  morphisms with their images. We write \( |q_{\Gamma}| \subseteq \tm(\Delta)(\Gamma) \) for the image,
  for each \( \Gamma \). Now what this diagram says is that for any
  \( q_{\Gamma }(r \in R(\Gamma)) = t \in |q_{\Gamma}|\), we have that
  \( t \circ \rho = q_{\Gamma'}(R(\rho)(r)) \in |q_{\Gamma'}|\). This is precisely the relative
  monotonicity condition for $\mathfrak{C}$-Kripke relations: containment in
  each predicate is functorial with respect to renaming \emph{up to renaming}.
  It turns out that the category of \(\ren\)-Kripke relations is a full
  subcategory of the gluing category \( \renhat \downarrow \tm \).

\begin{theorem}[Kripke full subcategory of gluing]
  TODO: maybe, I don't really think I will use this result.
  \end{theorem}
  \begin{proof}
    TODO
  \end{proof}

  The perspective gained above allows for a more conceptual understanding of the
  objects in the gluing category: the presheaves $R$ define context-indexed
  families of \emph{witnesses} to the inclusion of terms in the predicate, and
  $q$ is a quotient map that forgets the difference between distinct witnesses
  \( w, w' \in R(\Gamma) \) and whose image just records those terms
  \( t \in \tm (\Delta)(\Gamma)\) taken to be in the predicate; insofar as $q$ is a mono,
  these objects are exactly the variable-arity Kripke relations we considered
  classically at the beginning of this chapter.

  TODO: explain intuition for the morphisms of the gluing category
\section{Stratified syntax, theories, presheaves, algebras}
In this section, we will enlist a motely crew of \emph{presheaves of syntax}
which more-or-less represent families of terms in the lambda calculus. These
presheaves are defined over $\ren$ for reasons that will become apparent later.
We will ultimately define lambda algebras over these presheaves, for which we
require some understanding of how to represent variables in $\renhat$ and how
exponentiation in $\renhat$ corresponds to lambda abstraction. TODO: more
discussion: why presheaves of syntax? explain why we even want algebras in the
first place --- it is in order to glue them to the semantic algebra on $\tm$
\subsection{Variables and binding in Renhat}
\begin{definition}[Variable presheaf]\label{def:varpsh}
  We can define a presheaf of \emph{typed variables} in $\renhat$ with the Yoneda embedding on $\ren$:
  \[
    \mathfrak{V}_{\tau} = \yoneda \tau = \ren(-, \tau)
  \]

  With that definition, we have \( \varpsh(\Gamma) = \ren(\Gamma,\tau) \) where the
  right-hand side is comprised of renamings \( \Gamma \rightarrow [x:\tau]\) which are
  \emph{functions} \( \rho : \dom([x:\tau]) \rightarrow \dom(\Gamma)\) such that
  \( \Gamma(\rho(x)) = [x : \tau](x) = \tau\). That is, the \( \rho \) are functions selecting a
  variable of type $\tau$ in \( \Gamma \). More concisely, we have an isomorphism
  \( \varpsh(\Gamma) \cong \{ x \mid (x:\tau) \in \Gamma \}\) by which we allow ourselves to consider
  this a \emph{presheaf of syntax}.
\end{definition}

We can also explicate binding structure in \( \renhat \) thanks to the Yoneda
lemma. Let \( \mathfrak{P} : \renhat \). Exponentiation by a
representable/variable presheaf, \( \varpsh = \yoneda \tau\) gives

\begin{align*}
  \mathfrak{P}^{\mathfrak{V}_{\Delta}}(\Gamma)  &= \mathfrak{P}^{\yoneda \Delta}(\Gamma) \\
                                    &= \renhat[\yoneda \Gamma \times \yoneda \Delta, \mathfrak{P}] && (2)\\
                                    &\cong \renhat[\yoneda (\Gamma \times \Delta)] && (\textrm{since the Yoneda embedding is cartesian closed}) \\
                                    &\cong \mathfrak{P}(\Gamma\times\Delta) && (\textrm{by the Yoneda lemma})\\
\end{align*}

Where step (2) follows from the definition of the exponentials in the category
of presheaves, c.f. page 46 of \cite{mac_lane_sheaves_1992}.

The presheaves of typed variables together with the simplified view of
exponentials in $\renhat$ allow us to define algebras for a new lambda theory
\( \NN \) of stratified \emph{neutrals and normals} defined in the previous
section, which allow for a more fine-grained discussion of normal terms.

\subsection{Stratifying neutral and normal terms}
We introduce a new type system over the syntax and type structure of the lambda
calculus as defined in Chapter-\ref{chapter:stlc}. This new type system will
distinguish between \emph{neutral terms}, a special class of \emph{normal terms}
which are in some sense beta-redexes whose reduction is \emph{blocked} by a
variable in the head term, and all other normal terms. In some sense,
\emph{neutral terms} can be regarded as those terms which are normal only
because they're ``stuck.''

\begin{definition}[Neutral and normal judgments]\label{def:neut-norm-rules}
  \begin{mathpar}
    \inferrule*[Right={ \( (x:\tau) \in \Gamma \) }]{ }{ \Gamma \vdash_\neu x : \tau }\\
    \inferrule{ \Gamma \vdash_\neu M : \tau_1 * \tau_2}{\Gamma \vdash_\neu \pi_i M : \tau_i} \and \inferrule{ \Gamma \vdash_\neu t_{1} : \tau' \rightarrow \tau  \\  \Gamma \vdash_\nf t_{2} : \tau' }{ \Gamma \vdash_\neu t_{1} t_{2} : \tau } \\

    \inferrule{}{ \Gamma \vdash_\nf () : \termob } \and \inferrule{\Gamma \vdash_\nf N_i : \tau_i}{\Gamma \vdash_\nf (N_1, N_2) : \tau_1 * \tau_2} \and \inferrule{\Gamma, x : \tau \vdash_\nf b : \tau' }{\Gamma \vdash_\nf \abstr{x}{\tau}{b} : \tau \rightarrow \tau'} \\
    \inferrule*[Right={ ($\theta \in T$ \textrm{a base type}) }]{\Gamma \vdash_\neu t : \theta}{\Gamma \vdash_\nf t : \theta} \\
  \end{mathpar}
\end{definition}

\begin{definition}[Algebraic theory of neutrals and normals]\label{def:theory_neut_norm}
  The judgments above give rise to a lambda theory with a richer sort structure
  than that of the lambda theory defined back in Chapter \ref{chapter:stlc},
  because we differentiate between neutral terms of type \( \tau \) and normal
  terms of type \( \tau \).

  We define the lambda theory \( \NN \) as the algebraic theory (c.f.
  Theorem~\ref{thm:canonical_elementary_language}) corresponding to the category
  with the following objects and generating morphisms:
  \begin{enumerate}
    \item The objects are the collection generated by taking products and
          exponentials over the collection
          \( \Sigma = \{ \mathcal{M}_\tau \mid \tau \in \types \} \cup \{ \mathcal{N}_\tau \mid \tau \in \types \} \cup \{ \mathcal{V}_\tau \mid \tau \in \types \} \)
    \item Generating morphisms, for each \( \tau, \tau' \in \types \):
    \begin{align*}
      \textrm{var}_\tau &: \mathcal{V}_{\tau} \rightarrow \mathcal{M}_{\tau} \\
      \textrm{fst}_{\tau}^{\tau'} &: \mathcal{M}_{\tau \times \tau'} \rightarrow \mathcal{M}_{\tau}\\
      \textrm{snd}_{\tau}^{\tau'} &: \mathcal{M}_{\tau' \times \tau} \rightarrow \mathcal{M}_{\tau}\\
      \textrm{app}_{\tau}^{\tau'} &: \mathcal{M}_{\tau' \rightarrow \tau} \times \mathcal{N}_{\tau'} \rightarrow \mathcal{M}_{\tau}\\
      \textrm{incl}_{\theta} &: M_{\theta} \rightarrow N_{\theta} \\
       \textrm{unit} &: \termob \rightarrow \mathcal{N}_{\termob} \\
       \textrm{pair}_{\tau}^{\tau'} &: \mathcal{N}_{\tau} \rightarrow \mathcal{N}_{\tau'} \rightarrow \mathcal{N}_{\tau \times \tau'} \\
       \textrm{abs}_{\tau \rightarrow \tau'} &: {\mathcal{N}_{\tau'}}^{\mathcal{V}_{\tau}} \rightarrow \mathcal{N}_{\tau \rightarrow \tau'} \\
    \end{align*}
    \item The laws are the usual $\alpha-$, $\beta-$, and $\eta-$rules.
  \end{enumerate}
  Note that the domain of the unit operation symbol is merely the nullary
  product of sorts.
\end{definition}

\begin{remark}\label{rmk:upgrade_to_stratified}
  Any algebra \( \{ (\mathfrak{V}_{\tau}, \mathfrak{X}_{\tau}) \}_{\tau \in \types}\) of the
  lambda theory \( \mathcal{L}_{\alpha\beta\eta}\) (TODO: make this terminology consistent)
  from Chapter~\ref{chapter:stlc} gives rise to an algebra $\mathfrak{A}$ of the
  theory \( \NN \) by setting
  \begin{align*}
    \mathfrak{A}_{\mathcal{M}_{\tau}} &= \mathfrak{X}_{\tau} \\
    \mathfrak{A}_{\mathcal{N}_{\tau}} &= \mathfrak{X}_{\tau} \\
    \mathfrak{A}_{\mathcal{V}_{\tau}} &= \mathfrak{V}_{\tau}\\
  \end{align*}
\end{remark}

\begin{remark}[A lambda algebra of open substitutions]\label{rmk:tm-lam-alg}
  By Theorem~\ref{thm:classifying alg theory}, the syntactic category \( \cl \)
  of the theory \( \lambda-\alpha\beta\eta \) has a lambda algebra, and an induced intepretation
  of terms \( \sem{-} \).

  The morphism
  \begin{align*}
    \pi_{1} &: \sem{\tau} \times \sem{\tau'} \rightarrow \sem{\tau} \\
    \pi_{2} &: \sem{\tau} \times \sem{\tau'} \rightarrow \sem{\tau'} \\
    \epsilon     &: \sem{\tau'}^{\sem{\tau}} \times \sem{\tau} \rightarrow \sem{\tau'} \\
  \end{align*}

  in the syntactic category can be lifted to \( \renhat \) to provide the
  operations for a lambda algebra over the family
  \( \{ \tm(\tau) \}_{\tau \in \types} \)

  The operations are given as follows:
  \begin{align*}
    \varpsh &\xrightarrow{\sem{-}} \tm(\tau) \\
    \termob &\xrightarrow{i_{\termob}} \tm(\termob) \\
    \tm(\tau*\tau') &\xrightarrow{\tm(\pi_{1})} \tm(\tau) \\
    \tm(\tau*\tau') &\xrightarrow{\tm(\pi_{2})} \tm(\tau') \\
    \tm(\tau) \times \tm(\tau') &\xrightarrow{i_{\pi}} \tm(\tau*\tau') \\
    \tm({\tau'}^{\tau}) \times \tm(\tau) \xrightarrow{i_{\pi}} &\tm({\tau'}^{\tau} \times \tau) \xrightarrow{\tm(\epsilon)} \tm(\tau') \\
    \tm(\tau')^{\varpsh} &\xrightarrow{\cong} \tm(\tau \rightarrow \tau')
  \end{align*}
\end{remark}

\begin{remark}\label{rmk:tm-nn-alg}
  The lambda algebra just defined induces, by
  Remark~\ref{rmk:upgrade_to_stratified}, an \( \NN \)-algebra over \( \tm \) with the
  assignment of sorts
  \begin{align*}
    \mathcal{V}_{\tau} &\mapsto \tm(\tau) \\
    \mathcal{M}_{\tau} &\mapsto \tm(\tau) \\
    \mathcal{N}_{\tau} &\mapsto \tm(\tau) \\
  \end{align*}
  and letting the operations be exactly those of the lambda algebra (since the
  \( \mathcal{V}_{\tau} = \mathcal{M}_{\tau} = \mathcal{N}_{\tau} = \tm(\tau)\), the
  signatures of the required operations are exactly the same.)
\end{remark}

\subsection{Presheaves of syntax over the category of renamings}
\begin{definition}[A presheaf of open syntactic terms]
  For each type $\tau \in \types$, define
  \[
    \mathfrak{L}_{\tau} = \{ t \mid \Gamma \vdash t : \tau \}_{\Gamma \in \ren}
  \]
  Together with the \emph{renaming action}, defined for each $\rho : \Gamma' \rightarrow \Gamma $ as
  \begin{align*}
    \rho^{*} : \{ t \mid \Gamma \vdash t : \tau \} &\rightarrow \{ t \mid \Gamma' \vdash t : \tau \} \\
                             t &\mapsto \rho^{*}t
  \end{align*}
  where \( \rho^{*}t\) is the result of \( \rho \) (regarded as a substitution) acting
  on \( t \) by the action of the clone model (c.f. Theorem~\ref{thm:clone
    model}), the above families in fact define presheaves
  \[
    \mathfrak{L}_{\tau} : \renhat
  \]
  where (TODO?) functorialty of the renaming action is inherited from that of
  the clone model.
\end{definition}

\begin{remark}[A lambda algebra on the presheaves of open syntax]\label{def:open_syn_algebra}
  The presheaves of open syntax \( \mathfrak{L}_{\tau}\) form the objects of an
  algebra for the lambda theory \( \mathcal{L}_{\alpha\beta\eta} \) defined in
  Definition~\ref{def:alpha_beta_eta_theory}.

  The operations are given by the usual typing rules for the simply typed lambda
  calculus, as in Definition~\ref{def:stlc_rules}.
\end{remark}

\begin{remark}[A stratified-lambda algebra on the presheaves of open syntax]
  By Remark~\ref{rmk:upgrade_to_stratified},
  Definition~\ref{def:open_syn_algebra} induces an algebra of the lambda theory
  which stratifies neutral and normals.
\end{remark}

We can define presheaves of neutral and normal terms similarly, with the same
renaming action as before.

\begin{definition}[A presheaf of neutral terms]
  For each $\tau \in \types$, the families
  \[
    \mathfrak{Ne}_{\tau} = \{ t \mid \Gamma \nedash t : \tau \}_{\Gamma \in \ren}
  \]
  define a presheaf
  \[ \mathfrak{Ne}_{\tau} : \renhat \]
  under the renaming action.
\end{definition}

\begin{definition}[A presheaf of normal terms]
  For each $\tau \in \types$, the families
  \[
    \mathfrak{Nf}_{\tau} = \{ t \mid \Gamma \nfdash t : \tau \}_{\Gamma \in \ren}
  \]
  define a presheaf
  \[ \mathfrak{Nf}_{\tau} : \renhat\]
  under the renaming action.
\end{definition}

After teasing out the latent binding structure enjoyed by the category of
presheaves, we will find in Definition~\ref{def:strat-lam-alg}that the presheaves of neutrals and normals give rise
to a \( \NN \)-algebra over \( \renhat \).

\begin{remark}[Why the syntactic category just won't do]
  talk about why neutrals and normals can't support a substitution action
\end{remark}

\subsection{A stratified lambda-algebra of neutrals and normals in Renhat}
\begin{definition}[A stratified lambda-algebra of neutrals and normals]\label{def:strat-lam-alg}
  The presheaves of neutrals and normals defined above give rise to an algebra
  of the theory \( \NN \) in \( \renhat\). The sorts \( \mathcal{N}_{\tau}\) (resp.
  \( \mathcal{M}_{\tau} \)) are taken to be the presheaves \( \mathfrak{Nf}_{\tau}\)
  (resp.\( \mathfrak{Ne}_{\tau} \), and the sorts \( \mathcal{V}_{\tau}\) are taken to
  be the representable/variable presheaves \( \mathfrak{V}_{\tau} \) defined in Definition~\ref{def:varpsh}.

  The operations correspond to the typing rules of
  Definition~\ref{def:neut-norm-rules}.
\end{definition}

\begin{remark}\label{rmk:interpretations-into-tm}
  The \( \NN \)-algebra over \( (\tm, \tm) \) together with the \( \NN\)-algebra
  \( (\mathfrak{Ne}, \mathfrak{Nf}) \) just presented and the \( \NN\)-algebra on
  \( \mathfrak{L} \) induce interpretations \( l : \mathfrak{L} \rightarrow \tm \) and
  \( (m,n) : (\mathfrak{Ne}, \mathfrak{Nf}) \rightarrow (\tm, \tm) \) such that the
  following diagram commutes:

  % https://q.uiver.app/?q=WzAsNCxbMCwwLCJcXG1hdGhmcmFre05lfSJdLFsxLDAsIlxcbWF0aGZyYWt7TH0iXSxbMiwwLCJcXG1hdGhmcmFre05mfSJdLFsxLDEsIlxcbWF0aGZyYWt7VG19Il0sWzAsMSwiIiwwLHsic3R5bGUiOnsidGFpbCI6eyJuYW1lIjoibW9ubyJ9fX1dLFsyLDEsIiIsMix7InN0eWxlIjp7InRhaWwiOnsibmFtZSI6Im1vbm8ifX19XSxbMCwzLCJtIiwyXSxbMSwzLCJsIiwyXSxbMiwzLCJuIl1d
\[\begin{tikzcd}
	{\mathfrak{Ne}} & {\mathfrak{L}} & {\mathfrak{Nf}} \\
	& {\mathfrak{Tm}}
	\arrow[tail, from=1-1, to=1-2]
	\arrow[tail, from=1-3, to=1-2]
	\arrow["m"', from=1-1, to=2-2]
	\arrow["l"', from=1-2, to=2-2]
	\arrow["n", from=1-3, to=2-2]
\end{tikzcd}\]

The map \( l_{\tau} \) for each \( \tau \in \types \) is the usual semantic
interpretation of terms in the syntactic category:
\begin{align*}
  l_{\tau}(\Gamma) : \mathfrak{L}_{\tau}(\Gamma) &\rightarrow \tm(\tau)(\Gamma) \\
  t &\mapsto \sem{\Gamma \vdash t : \tau} \\
\end{align*}

The maps \( m_{\tau} \), \( n_{\tau}\) are the usual semantic interpretation
precomposed with the relevant inclusion.
\end{remark}

\section{Onward!}
\subsection{Cartesian closed structure for the gluing category}

\begin{theorem}[Exponentials in the gluing category]
  For objects \( (R_{1}, q_{1}, \Delta_{1})\) and \( (R_{2},q_{2},\Delta_{2})\) in
  \( \gl \), the exponential \( (R_{2}, q_{2}, \Delta_{2})^{(R_{1}, q_{1}, \Delta_{1})}\)
  is \( (R, q, {\Delta_{2}}^{\Delta_{1}}) \) in the pullback diagram
  \[\begin{tikzcd}
      R && {{R_2}^{R_1}} \\
      \\
      {\mathfrak{Tm}(\Delta_2 ^ {\Delta_1})} && {\mathfrak{Tm}(\Delta_2)^{R_1}} \\
      \\
      \\
      && {}
      \arrow["q"', from=1-1, to=3-1]
      \arrow["r", from=1-1, to=1-3]
      \arrow["{{q_2}_*}", from=1-3, to=3-3]
      \arrow["{{q_1}^* \circ \tilde{p}}"', from=3-1, to=3-3]
    \end{tikzcd}\]
  where \[ p = \tm(\epsilon) \circ (\tm(\Delta_{2}^{\Delta_{1}}) \times \tm(\Delta_{1}) \xrightarrow{\cong} \tm(\Delta_{2}^{\Delta_{1}}\times \Delta_{1})) \]  is the composition of the lifting of the syntactic category's evaluation to
  \( \renhat \) with the isomorphism witnessing the product preservation of
  \( \tm \), and \( \tilde{p} \) is its exponential transpose.
\end{theorem}

\begin{proof}
  The universal property for exponentials is encoded by the product-hom
  adjunction. It suffices to show an isomorphism
  \[ \gl[(R_{X}, q_{X}, \Delta_{X})\times(R_{Y}, q_{Y}, \Delta_{Y}), (R_{Z}, q_{Z}, \Delta_{Z})] \equiv \gl[(R_{X}, q_{X}, \Delta_{X}), (R_{Z},q_{Z},\Delta_{Z})^{(R_{Y}, q_{Y}, \Delta_{Y})}] \]

  recalling the definition of products in the gluing category, we must show

  \[ \phi : P \cong E : \psi \]

  where
  \begin{align*}
    &\tm(\Delta_{2}^{\Delta_{1}}) \times \tm(\Delta_{1}) \xrightarrow{i_{\pi}} \tm(\Delta_{2}^{\Delta_{1}}\times \Delta_{1}) \\
    &P = \gl[(R_{X} \times R_{Y}, i_{\pi} \circ (q_{X} \times q_{Y}),  \Delta_{X} \times \Delta_{Y}), (R_{Z}, q_{Z}, \Delta_{Z})] \\
    &E = \gl[(R_{X}, q_{X}, \Delta_{X}), (R_{Z},q_{Z},\Delta_{Z})^{(R_{Y}, q_{Y}, \Delta_{Y})}] \\
  \end{align*}

  To come up with this isomorphism, it helps to recognize what the morphisms of
  the relevant gluing objects are. Some consideration reveals that the
  components of the map \( \phi \) are given by the dotted arrows in the diagram
  below.

  % https://q.uiver.app/?q=WzAsMTksWzAsMCwiUl9YXFx0aW1lcyBSX1kiXSxbMCwyLCJcXG1hdGhmcmFre1RtfShcXERlbHRhX1hcXHRpbWVzXFxEZWx0YV9ZKSJdLFszLDIsIlxcbWF0aGZyYWt7VG19KFxcRGVsdGFfWikiXSxbMywwLCJSX1oiXSxbMCw3LCJcXG1hdGhmcmFre1RtfShcXERlbHRhX1gpIl0sWzEsNywiXFxtYXRoZnJha3tUbX0oe1xcRGVsdGFfWn1ee1xcRGVsdGFfWX0pIl0sWzEsNSwiUiJdLFszLDUsIntSX1p9XntSX1l9Il0sWzMsNywiXFxtYXRoZnJha3tUbX0oXFxEZWx0YV9aKV57Ul9ZfSJdLFs1LDFdLFswLDUsIlJfWCJdLFsxLDBdLFsxLDJdLFs1LDBdLFs1LDJdLFswLDNdLFsyLDZdLFsxLDRdLFsxLDNdLFswLDMsImQiXSxbMywyLCJxX1oiXSxbMCwxLCJpX1xccGkgXFxjaXJjIChxX1hcXHRpbWVzIHFfWSkiLDJdLFsxLDIsIlxcZGVsdGEiLDJdLFs2LDcsInIiXSxbNyw4LCJ7cV9afV8qIl0sWzYsNSwicSIsMl0sWzUsOCwie3FfWX1eKiBcXGNpcmMgXFx3aWRldGlsZGV7XFxtYXRoZnJha3tUbX0oXFxlcHNpbG9uKSBcXGNpcmMgaV9cXHBpfSIsMl0sWzEwLDYsImQnIiwwLHsic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoiZGFzaGVkIn19fV0sWzEwLDQsInFfWCIsMl0sWzQsNSwiXFxkZWx0YSciLDIseyJzdHlsZSI6eyJib2R5Ijp7Im5hbWUiOiJkYXNoZWQifX19XSxbNiwxNiwiIiwwLHsic3R5bGUiOnsibmFtZSI6ImNvcm5lciJ9fV0sWzE4LDE3LCIiLDAseyJsYWJlbF9wb3NpdGlvbiI6NDAsIm9mZnNldCI6LTUsImxldmVsIjoyLCJzdHlsZSI6eyJib2R5Ijp7Im5hbWUiOiJkYXNoZWQifX19XV0=
\[\begin{tikzcd}
	{R_X\times R_Y} & {} && {R_Z} && {} \\
	&&&&& {} \\
	{\mathfrak{Tm}(\Delta_X\times\Delta_Y)} & {} && {\mathfrak{Tm}(\Delta_Z)} && {} \\
	{} & {} \\
	& {} \\
	{R_X} & R && {{R_Z}^{R_Y}} \\
	&& {} \\
	{\mathfrak{Tm}(\Delta_X)} & {\mathfrak{Tm}({\Delta_Z}^{\Delta_Y})} && {\mathfrak{Tm}(\Delta_Z)^{R_Y}}
	\arrow["d", from=1-1, to=1-4]
	\arrow["{q_Z}", from=1-4, to=3-4]
	\arrow["{i_\pi \circ (q_X\times q_Y)}"', from=1-1, to=3-1]
	\arrow["\delta"', from=3-1, to=3-4]
	\arrow["r", from=6-2, to=6-4]
	\arrow["{{q_Z}_*}", from=6-4, to=8-4]
	\arrow["q"', from=6-2, to=8-2]
	\arrow["{{q_Y}^* \circ \widetilde{\mathfrak{Tm}(\epsilon) \circ i_\pi}}"', from=8-2, to=8-4]
	\arrow["{d'}", dashed, from=6-1, to=6-2]
	\arrow["{q_X}"', from=6-1, to=8-1]
	\arrow["{\delta'}"', dashed, from=8-1, to=8-2]
	\arrow["\lrcorner"{anchor=center, pos=0.125}, draw=none, from=6-2, to=7-3]
	\arrow["{\phi}", shift left=5, Rightarrow, dashed, from=4-2, to=5-2]
\end{tikzcd}\]

where
\( \tm(\Delta_{Z})^{\tm(\Delta_{Y})} \xrightarrow{i_{e}} \tm(\Delta_{Z}^{\Delta_{Y}})\) is the
isomorphism witnessing exponential preservation for the relative hom functor. Observing the arrows in sight, a clear choice for \( \delta' \) is
\[ i_{e} \circ \widetilde{\delta \circ i_{\pi}} \] The choice for \( d' \) is a trickier
question. \( d' \) should be an arrow into the pullback \( R \). We know nothing
about nothing about \( R \) except that it fits into the pullback diagram above.
The up-side of our limited knowledge of \( R \) is that it makes our choice of
\( d' \) automatic: it must be one of the mediators required by the universal
property of the pullback. In particular, we will want to choose \( d' = ! \) in
the diagram below after verifying that the outer square commutes.
% https://q.uiver.app/?q=WzAsNixbMSwxLCJSIl0sWzAsMCwiUl9YIl0sWzEsMywiXFxtYXRoZnJha3tUbX0oe1xcRGVsdGFfWn1ee1xcRGVsdGFfWX0pIl0sWzMsMywiXFxtYXRoZnJha3tUbX0oXFxEZWx0YV9aKV57Ul9ZfSJdLFszLDEsIntSX1p9XntSX1l9Il0sWzIsMl0sWzAsNCwiciJdLFs0LDMsIntxX1p9XyoiXSxbMCwyLCJxIiwyXSxbMiwzLCJ7cV9ZfV4qIFxcY2lyYyBcXHdpZGV0aWxkZXtcXG1hdGhmcmFre1RtfShcXGVwc2lsb24pIFxcY2lyYyBpX1xccGl9IiwyXSxbMCw1LCIiLDIseyJzdHlsZSI6eyJuYW1lIjoiY29ybmVyIn19XSxbMSwyLCJcXGRlbHRhJyBcXGNpcmMgcV9YIiwyLHsiY3VydmUiOjN9XSxbMSw0LCJcXHRpbGRle2R9IiwwLHsiY3VydmUiOi0zfV0sWzEsMCwiXFxleGlzdHMhZCciLDIseyJzdHlsZSI6eyJib2R5Ijp7Im5hbWUiOiJkb3R0ZWQifX19XV0=
\[\begin{tikzcd}
	{R_X} \\
	& R && {{R_Z}^{R_Y}} \\
	&& {} \\
	& {\mathfrak{Tm}({\Delta_Z}^{\Delta_Y})} && {\mathfrak{Tm}(\Delta_Z)^{R_Y}}
	\arrow["r", from=2-2, to=2-4]
	\arrow["{{q_Z}_*}", from=2-4, to=4-4]
	\arrow["q"', from=2-2, to=4-2]
	\arrow["{{q_Y}^* \circ \widetilde{\mathfrak{Tm}(\epsilon) \circ i_\pi}}"', from=4-2, to=4-4]
	\arrow["\lrcorner"{anchor=center, pos=0.125}, draw=none, from=2-2, to=3-3]
	\arrow["{\delta' \circ q_X}"', curve={height=18pt}, from=1-1, to=4-2]
	\arrow["{\tilde{d}}", curve={height=-18pt}, from=1-1, to=2-4]
	\arrow["{\exists!d'}"', dotted, from=1-1, to=2-2]
\end{tikzcd}\]

To verify that the outer square commutes, We need to demonstrate
that \[ q_{Y}^{*} \circ \widetilde{\tm(\epsilon) \circ i_{\pi}} \circ i_{e} \circ \widetilde{\delta \circ i_{\pi}} \circ q_{X} = {q_{Z}}_{*} \circ \tilde{d} \]
which should strike the reader as suspiciously similar to our gluing morphism
hypothesis that \[ \delta \circ i_{\pi} \circ (q_{X} \times q_{Y}) = q_{Z} \circ d \]

Passing to our higher order notation in \( \renhat \), we can express the
left-hand side of the desired equality as a ``lambda expression'' (TODO phrasing)
\begin{align*}
  &\lambda y'.\, (\lambda y.\, \delta ((q_{X}(x:R_{x}, y)))) q_{Y}(y') \\
  = &\lambda y.\, \delta (q_{X}(x: R_{X}), q_{Y}(y)) && (\alpha, \beta) \\
\end{align*}

The transpose of the lower composite in the original gluing morphism diagram is
\( \widetilde{\delta \circ i_{\pi} \circ (q_{X} \times q_{Y})}\); it can be rendered as a lambda
expression as \( \lambda y: R_{Y}.\, \delta(q_{X}\times q_{Y} (x : R_{X}, y))\) hence by the
definition of the product functor, the left-hand side of our desired equality is
precisely the transpose of the lower composite in the original gluing morphism
diagram.

The right-hand side of the desired equality is the transpose of the upper
composite in the gluing morphism diagram so that the desired equality holds
because transposition preserves equality of morphisms (TODO: cite? this is
obviously true by an appeal to the lambda calculus, but I'm not sure whether
this is a well-known theorem in cat theory.)

We now summarize the rightward map for the isomorphism:

\begin{align*}
  \phi_{1}(d) &= d' && (\textrm{the unique mediating arrow from the argument above})\\
  \phi_{2}(\delta) &= i_{e} \circ \widetilde{\delta \circ i_{\pi}}
\end{align*}


The leftward side of the isomorphism, \( \psi \), is substantially easier,
because we don't need to interact much with the pullback. We define

\begin{align*}
  \psi_{1}(d') &= \epsilon \circ ((d' \circ r) \times \id)  \\
  \psi_{2}(\delta') &= \tm(\epsilon) \circ (\delta' \times \id) \\
\end{align*}

With our maps in hand, we can verify that they form a bijection:

\begin{align*}
  \psi_{1}(\phi_{1}(d)) &= \epsilon \circ ((d' \circ r) \times \id) \\
  \psi_{2}(\phi_{2}(\delta)) &= \tm(\epsilon) \circ ((i_{e} \circ \widetilde{\delta \circ i_{\pi}}) \times \id) \\
\end{align*}

Because we have defined \( d' \) by the universal property of the pullback, we
have that \( d' \circ r = \tilde{d} \) whence
\( \psi_{1}(\phi_{1}(d)) = \epsilon \circ (\tilde{d} \times \id) \) by the universal property of the
transpose in \( \renhat \). The second equality is a little trickier.

Both of these are the universal property for the relevant transpose up to
squinting, so I think they should be the identity...

TODO:
\begin{itemize}
  \item finish up the bijection proof
  \item prove naturality
\end{itemize}
\end{proof}

\subsection{Gluing syntax to semantics, and a glued algebra}
We will define some objects in the gluing category which, in some sense, glue
the presheaves of syntax we have defined in \( \renhat \) together with their
semantics in the classifying category.

\begin{definition}\label{def:yonedabar}
  The relative hom functor induces the embedding
  \begin{align*}
    \overline{\yoneda} : \ren &↪ \gl \\
    \Gamma &\mapsto (\yoneda(\Gamma), \yoneda(\Gamma) \xrightarrow{\underline{\iota}_{\Gamma}} \tm(\Gamma), \Gamma) \\
  \end{align*}
  where
  \begin{align*}
    (\underline{\iota}_{\Gamma})_{\Delta} : \ren[\Delta, \Gamma] &\rightarrow \cl[\Delta, \Gamma] \\
    \rho &\mapsto \iota(\rho) \\
  \end{align*}

  which fits into the following diagram
  % https://q.uiver.app/?q=WzAsNyxbMiwwLCJcXHJlbiJdLFsyLDEsIlxcZ2wiXSxbMCwxLCJcXHJlbmhhdCJdLFs0LDEsIlxcY2wiXSxbMiwyLCIoUixxLFxcRGVsdGEpIl0sWzQsMiwiXFxEZWx0YSJdLFswLDIsIlIiXSxbMCwxLCJcXG92ZXJsaW5le1xceW9uZWRhfSIsMCx7InN0eWxlIjp7InRhaWwiOnsibmFtZSI6Imhvb2siLCJzaWRlIjoidG9wIn19fV0sWzAsMiwiXFx5b25lZGEiLDIseyJzdHlsZSI6eyJ0YWlsIjp7Im5hbWUiOiJob29rIiwic2lkZSI6InRvcCJ9fX1dLFswLDMsIlxcaW90YSIsMCx7InN0eWxlIjp7InRhaWwiOnsibmFtZSI6Imhvb2siLCJzaWRlIjoiYm90dG9tIn19fV0sWzEsM10sWzEsMl0sWzQsNSwiXFxzZW1wcm9qIiwwLHsic3R5bGUiOnsidGFpbCI6eyJuYW1lIjoibWFwcyB0byJ9fX1dLFs0LDYsIlxcc3lucHJvaiIsMix7InN0eWxlIjp7InRhaWwiOnsibmFtZSI6Im1hcHMgdG8ifX19XV0=
\[\begin{tikzcd}
	&& \ren \\
	\renhat && \gl && \cl \\
	R && {(R,q,\Delta)} && \Delta
	\arrow["{\overline{\yoneda}}", hook, from=1-3, to=2-3]
	\arrow["\yoneda"', hook, from=1-3, to=2-1]
	\arrow["\iota", hook', from=1-3, to=2-5]
	\arrow[from=2-3, to=2-5]
	\arrow[from=2-3, to=2-1]
	\arrow["\semproj", maps to, from=3-3, to=3-5]
	\arrow["\synproj"', maps to, from=3-3, to=3-1]
\end{tikzcd}
\]

and satisfies the following form of the Yoneda lemma:
% https://q.uiver.app/?q=WzAsNixbMCwwLCIoZCxcXGRlbHRhKSJdLFsyLDAsImQoXFxpZCkiXSxbMCwxLCJcXGdsW1xcb3ZlcmxpbmV7XFx5b25lZGEoLSl9LCAoUixxLFxcRGVsdGEpXSJdLFsyLDEsIlIoLSkiXSxbMSwyLCJcXGNsW1xcaW90YSgtKSxcXERlbHRhXT1cXHRtKFxcRGVsdGEpIl0sWzEsMV0sWzAsMSwiIiwwLHsic3R5bGUiOnsidGFpbCI6eyJuYW1lIjoibWFwcyB0byJ9fX1dLFsyLDMsIlxcY29uZyJdLFszLDQsInEiXSxbMiw0LCJcXHNlbXByb2oiLDJdXQ==
\[\begin{tikzcd}
	{(d,\delta)} && {d(\id)} \\
	{\gl[\overline{\yoneda}(-), (R,q,\Delta)]} & {} & {R(-)} \\
	& {\cl[\iota(-),\Delta]=\tm(\Delta)}
	\arrow[maps to, from=1-1, to=1-3]
	\arrow["\cong", from=2-1, to=2-3]
	\arrow["q", from=2-3, to=3-2]
	\arrow["\semproj"', from=2-1, to=3-2]
\end{tikzcd}\]
\end{definition}

This embedding allows us to define a typed-indexed family of glued objects which
glue the syntax, $x,y,z,\ldots,$ etc., of variables to the their semantics as
substitutions.

\newcommand{\yonedabar}{\overline{\yoneda}}

\begin{definition}[Gluing syntax and semantics of variables]
  We define the glued
  object \[ \nu_{\tau} = \yonedabar(\tau) = (\varpsh, \varpsh \rightarrow \tm(\tau), \tau)\] where the
  components of the gluing map are the interpretation of terms in the
  classifying category.
\end{definition}

We do the same for the syntactic presheaves of neutrals and normals we defined
earlier. In each case, the components of the quotient map are the interpretation
of terms in the classifying category.

\begin{definition}[Gluing syntax and semantics of neutrals]
  \[ \mu_{\tau} = (\neut, \neut \xrightarrow{m_{\tau}} \tm(\tau), \tau) \]
\end{definition}

\begin{definition}[Gluing syntax and semantics of normals]
  \[ \eta_{\tau} = (\norm, \norm \xrightarrow{n_{\tau}} \tm(\tau), \tau) \]
\end{definition}

With these glued objects, we can define an \( \NN \)-algebra over these families
of glued variables, glued neutrals, and glued normals. In turn
Definition~\ref{def:term model} will allow us to leverage this to interpret
substitutions as gluing category morphisms between these glued objects. The
algebra we define will be constructed by ``gluing together'' the syntactic
\( \NN \)-algebra in \( \renhat \) together with the semantic
\( \NN \)-algebra\footnote{i.e., the one induced by
  Remark~\ref{rmk:upgrade_to_stratified} and the usual lambda algebra in the
  classifying category} in the classifying category.

\begin{definition}[An algebra of stratified neutrals and normals in the gluing category]\label{def:glued-algebra}
  The family \( \{ (\mu_{\tau}, \eta_{\tau})\}_{\tau\in\types}\) define the objects of an
  \( \NN \)-algebra with the operations given as follows:
  \begin{itemize}
    \item For each \( \tau, \tau' \in \types\), the pair of maps
    \[ (\var_{\tau} : \varpsh \rightarrow \mathfrak{Ne}_{\tau} , \id_{\sem{\tau}})\]
    is a map \( \nu_{\tau} \rightarrow \mu_{\tau} \) in \( \renhat \downarrow \tm \).
    \item For each \( \tau, \tau' \in \types\), the pair of maps
    \[ (\fst_{\tau}^{\tau'} : \mathfrak{Ne}_{\tau*\tau'} \rightarrow \mathfrak{Ne}_{\tau}, \pi_{1} : \sem{\tau} \times \sem{\tau'} \rightarrow \sem{\tau}) \]
    is a map \( \mu_{\tau*\tau'} \rightarrow \mu_{\tau} \) in \( \renhat \downarrow \tm \).
    \item For each \( \tau, \tau' \in \types\), the pair of maps
    \[ (\snd_{\tau}^{\tau'} : \mathfrak{Ne}_{\tau'*\tau} \rightarrow \mathfrak{Ne}_{\tau}, \pi_{2} : \sem{\tau'} \times \sem{\tau} \rightarrow \sem{\tau}) \]
    is a map \( \mu_{\tau'*\tau} \rightarrow \mu_{\tau} \) in \( \renhat \downarrow \tm \).
    \item For each \( \tau, \tau' \in \types\), the pair of maps
    \[ (\app_{\tau}^{\tau'} : \mathfrak{Ne}_{\tau'\rightarrow\tau} \times \mathfrak{Nf}_{\tau'} \rightarrow \mathfrak{Ne}_{\tau}, \epsilon : (\sem{\tau'} \rightarrow \sem{\tau}) \times \sem{\tau'} \rightarrow \sem{\tau}) \]
    is a map \( \mu_{\tau'\rightarrow\tau} \times \eta_{\tau'} \rightarrow \mu_{\tau}\) in \( \renhat \downarrow \tm \).


    \item For each base type \( \theta \in T\), the pair of \emph{isomorphisms}
          \[ \mathfrak{Ne}_{\theta} \cong \mathfrak{Nf}_{\theta} , \id_{\sem{\theta}}\] is an
          isomorphism \( \mu_{\theta} \cong \eta_{\theta}\) in \( \renhat \downarrow \tm \).
    \item The pair of isomorphisms
          \[ \termob \cong \mathfrak{Nf}_{\termob}, \id_{\termob}\] is an isomorphism
          \( \termob \cong \eta_{\termob}\) in \( \renhat \downarrow \tm \).
    \item For \( \tau, \tau' \in \types \), the pair of isomorphisms
          \[ \pair_{\tau*\tau'} : \mathfrak{Nf}_{\tau} \times \mathfrak{Nf}_{\tau'} \xrightarrow{\cong} \mathfrak{Nf}_{\tau*\tau'} , \id_{\sem{\tau} \times \sem{\tau'}}\]
          is an isomorphism \( \eta_{\tau} \times \eta_{\tau'} \xrightarrow{\cong} \eta_{\tau*\tau'} \) in
          \( \renhat \downarrow \tm \).
          \item For \( \tau, \tau' \in \types \), the pair of isomorphisms
          \[ \abs_{\tau \rightarrow \tau'} : \mathfrak{Nf}_{\tau'}^{\varpsh} \xrightarrow{\cong} \mathfrak{Nf}_{\tau \rightarrow \tau'}, \id_{\sem{\tau'}^{\sem{\tau}}}\]
          is an isomorphism \( \eta_{\tau'}^{\nu_{\tau}} \xrightarrow{\cong} \eta_{\tau\rightarrow\tau'}\) in \( \renhat \downarrow \tm \).
  \end{itemize}
\end{definition}

Note that the glued operations are given by pairs of syntactic operations and
\emph{semantic operations} for elimination forms, and pairs of syntactic
operations and the \emph{identity} in the for introduction forms.

Finally we can give an interpretation of base types in the gluing category in terms of the glued neutrals
\begin{align*}
  T &\xrightarrow{\bar{s}} \renhat \downarrow \tm \\
  \theta &\mapsto \mu_{\theta}\\
\end{align*}

Let \(s\sem{-} : \types \rightarrow \cl \) be the the interpretation of terms in the
syntactic category induced by the usual interpretation of types as singleton
contexts. By (TODO: $\pi_2$ second component gluing projection), the
interpretation of terms induced by \( \bar{s} \) according to
Definition~\ref{def:term model} extends the interpretation of terms in the
syntactic category in the following sense: \( \bar{s}\sem{\Gamma \vdash t : \tau} \) is
a pair of the form $(s'\sem{ \Gamma \vdash t : \tau}, s\sem{\Gamma \vdash t : \tau })$ where
\( s' : \cl \rightarrow \renhat \) is the unique functor induced by the $\renhat-$lambda
algebra of neutral and normals from
Definition~\ref{def:glued-algebra} and the cartesian closed structure
of the category of presheaves. Now is a good time to take stock of what we have
developed so far, and look ahead to where we're going.

\subsection{Taking stock: charting a path to normalization}\label{sec:taking-stock}
\newcommand{\opens}{\mathfrak{L}}

For all this talk of normalization, and blood sweat and tears expended for its
benefit, we haven't talked much about what a normalization function must be. Of
course, it should take a lambda term to a normal form, but the desiderata are
far more than that. The following are some of the important properties a
normalization function \( \nf_{\tau}^{\Gamma} : \opens_{\tau}(\Gamma) \rightarrow \nfpsh(\Gamma) \) should
satisfy:
\begin{itemize}
  \item Compatibility with context renamings: For each morphism \( \rho : \Delta \rightarrow \Gamma \) of \( \ren \) and term \( t \in \opens_{\tau}(\Gamma)\),
        \[ \rho^{*} \, \nf_{\tau}^{\Gamma}(t) = \nf_{\tau}^{\Delta}(\rho^{*} \, t)\]

  \item Idempotence: For all normal terms \( n \in \nfpsh(\Gamma) \),
  \[ \nf_{\tau}^{\Gamma}(n) = n \]

  \item Semantics preservation: For all terms \( t \in \opens_{\tau}(\Gamma)\),
  \[ \nf_{\tau}^{\Gamma} (t) \equiv_{\beta\eta} t\]

  \item Equation preservation (TODO: not really sure I grok the importance of
        this one, whence the stupid name): For all terms
        \( t, t' \in \opens_{\tau}(\Gamma) \),
        \[ t \equiv_{\beta\eta} t' \Rightarrow \nf_{\tau}^{\Gamma} (t) = \nf_{\tau}^{\Gamma} (t') \]
\end{itemize}

[TODO: say here something about how the proofs of each of these will ``fall
out'' of the way we have constructed our normalization function with gluing. ]

We now have enough language to say exactly what it is we're hoping to acquire in
this chapter. Let \( \tau \in \types \) and suppose
\( \sem{\tau}_{\gl} = (\mathfrak{R}_{\tau}, q, \tau) \). We wish to come up with maps
\( \uparrow_{\tau}\) (pronounced ``reflect'', or for the LISPer ``unquote'') and
\( \downarrow_{\tau}\) (pronounced ``reify'', or for the LISPer ``quote'') at each type
\( \tau \in \types \) to fill in the dotted arrows in the upper diagram such that the
lower diagram commutes. In classical approaches to normalization by evaluation,
reflection can be construed as ``lifting'' syntax into a semantic domain, while
reification is thought of as ``lowering'' semantic objects to a syntactic
representation.

% https://q.uiver.app/?q=WzAsNCxbMCwwLCJcXG1hdGhmcmFre05lfV9cXHRhdSJdLFsyLDAsIlxcbWF0aGZyYWt7Un1fXFx0YXUiXSxbNCwwLCJcXG1hdGhmcmFre05mfV9cXHRhdSJdLFsyLDEsIlxcbWF0aGZyYWt7VG19Il0sWzAsMSwiXFx1cGFycm93X1xcdGF1IiwwLHsic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoiZG90dGVkIn19fV0sWzEsMiwiXFxkb3duYXJyb3dfXFx0YXUiLDAseyJzdHlsZSI6eyJib2R5Ijp7Im5hbWUiOiJkb3R0ZWQifX19XSxbMiwzLCJuX1xcdGF1Il0sWzAsMywibV9cXHRhdSIsMl0sWzEsMywicl9cXHRhdSIsMl1d
\[\begin{tikzcd}
	{\mathfrak{Ne}_\tau} && {\mathfrak{R}_\tau} && {\mathfrak{Nf}_\tau} \\
	&& {\mathfrak{Tm}(\tau)}
	\arrow["{\uparrow_\tau}", dotted, from=1-1, to=1-3]
	\arrow["{\downarrow_\tau}", dotted, from=1-3, to=1-5]
	\arrow["{n_\tau}", from=1-5, to=2-3]
	\arrow["{m_\tau}"', from=1-1, to=2-3]
	\arrow["{r_\tau}"', from=1-3, to=2-3]
\end{tikzcd}\]

% https://q.uiver.app/?q=WzAsOSxbMCwwLCJcXHByb2RfaVxcbWF0aGZyYWt7TmV9X3tcXHRhdV9pfSAiXSxbMiwwLCJcXHByb2RfaVxcbWF0aGZyYWt7Un1fe1xcdGF1X2l9Il0sWzQsMCwiXFxtYXRoZnJha3tOZn1fe1xcdGF1fSJdLFsxLDBdLFsyLDEsIlxccHJvZF9pXFx0ZXh0cm17Q259X1xcbWF0aGNhbHtcXGxhbWJkYX1ee1xccmlnaHRhcnJvd30oLSxcXHRhdV9pKSJdLFsxLDFdLFsyLDIsIlxcdGV4dHJte0NufV9cXG1hdGhjYWx7XFxsYW1iZGF9XntcXHJpZ2h0YXJyb3d9KC0sXFxHYW1tYSkiXSxbMywwLCJcXG1hdGhmcmFre1J9X1xcdGF1Il0sWzQsMiwiXFx0ZXh0cm17Q259X1xcbWF0aGNhbHtcXGxhbWJkYX1ee1xccmlnaHRhcnJvd30oLSxcXHRhdSkiXSxbMCwxLCJcXHByb2RfaVxcdXBhcnJvd157XFx0YXVfaX0iXSxbMSw0LCJcXHByb2RfaSByX3tcXHRhdV9pfSJdLFswLDQsIlxccHJvZF9pbV97XFx0YXVfaX0iLDJdLFs0LDYsIlxcY29uZyJdLFs3LDIsIlxcZG93bmFycm93XntcXHRhdX0iXSxbMSw3LCJcXG1hdGhiYntzfVxcbGxicmFja2V0XFxHYW1tYVxcdmRhc2ggdDpcXHRhdVxccnJicmFja2V0Il0sWzYsOCwic1xcbGxicmFja2V0XFxHYW1tYVxcdmRhc2ggdCA6IFxcdGF1IFxccnJicmFja2V0XyoiLDJdLFsyLDgsIm5fXFx0YXUiXSxbNyw4LCJyX1xcdGF1IiwyXV0=
\[\begin{tikzcd}
	{\prod_i\mathfrak{Ne}_{\tau_i} } & {} & {\prod_i\mathfrak{R}_{\tau_i}} & {\mathfrak{R}_\tau} & {\mathfrak{Nf}_{\tau}} \\
	& {} & {\prod_i\textrm{Cn}_{\mathcal{\lambda}}^{\rightarrow}(-,\tau_i)} \\
	&& {\textrm{Cn}_{\mathcal{\lambda}}^{\rightarrow}(-,\Gamma)} && {\textrm{Cn}_{\mathcal{\lambda}}^{\rightarrow}(-,\tau)}
	\arrow["{\prod_i\uparrow^{\tau_i}}", from=1-1, to=1-3]
	\arrow["{\prod_i r_{\tau_i}}", from=1-3, to=2-3]
	\arrow["{\prod_im_{\tau_i}}"', from=1-1, to=2-3]
	\arrow["\cong", from=2-3, to=3-3]
	\arrow["{\downarrow^{\tau}}", from=1-4, to=1-5]
	\arrow["{\mathbb{s}\llbracket\Gamma\vdash t:\tau\rrbracket}", from=1-3, to=1-4]
	\arrow["{s\llbracket\Gamma\vdash t : \tau \rrbracket_*}"', from=3-3, to=3-5]
	\arrow["{n_\tau}", from=1-5, to=3-5]
	\arrow["{r_\tau}"', from=1-4, to=3-5]
\end{tikzcd}\]

Supposing we can achieve this, our normalization function will be precisely the
the upper-right composite of the lower diagram. Because the diagram commutes,
the normalization function computes for a term $t$ a normal form with the same
\emph{semantics} as $t$; that is, as evident from the diagram, we will have an
equality of morphisms \( t \equiv \nf(t)\) in the syntactic category.

\subsection{Reify-reflect yoga}
In this section we will actually define the reify-reflect maps for each type.

\begin{definition}[Reify-reflect yoga]
  The maps are defined by induction on the type structure of \( \types \):
  \begin{itemize}
    \item For a base type \( \theta \in T \), we define \( \uparrow^{\theta} = \id_{\mu_{\theta}} \) and
    \( \downarrow^{\theta} = \mu_{\theta} \xrightarrow[\cong]{\incl_{\theta}} \eta_{\theta} \)
    \item For the empty product/unit type \( \termob \), we define \( \uparrow^{\termob} = (\mu_{\termob} \xrightarrow[\cong]{!} \termob )\) and \( \downarrow^{\termob} = (\termob \xrightarrow[\cong]{(\unit, \id)} \eta_{\termob})\)
    \item For types \( \tau, \tau' \in \types\), we define
    \[ \uparrow^{\tau*\tau'} : \mu_{\tau*\tau'} \rightarrow \sem{\tau}_{\cl} \times \sem{\tau'}_{\cl}\] as the pair of the following composites:
    \begin{align*}
      &\mu_{\tau*\tau'} \xrightarrow{(\fst_{\tau}^{\tau'}, \pi_{1})} \mu_{\tau} \xrightarrow{\uparrow^{\tau}} \sem{\tau}_{\gl} \\
      &\mu_{tau*\tau'} \xrightarrow{(\snd_{\tau'}^{\tau}, \pi_{2})} \mu_{\tau'} \xrightarrow{\uparrow^{\tau'}} \sem{\tau'}_{\gl} \\
    \end{align*}

    and define \( \downarrow^{\tau*\tau'} : \sem{\tau}_{\gl} \times \sem{\tau'}_{\gl} \rightarrow \eta_{\tau*\tau'}\) as the composite
    \[ \sem{\tau}_{\gl}\times \sem{\tau'}_{\gl} \xrightarrow{\downarrow^{\tau}\times \downarrow^{\tau'}} \xrightarrow[\cong]{(\pair_{\tau*\tau'}, \id)}     \eta_{\tau*\tau'} \]

    \item For types \( \tau, \tau' \in \types \), we define the reflection map
    \[ \uparrow^{\tau\rightarrow\tau'} : \mu_{\tau\rightarrow\tau'} \rightarrow {\sem{\tau'}_{\gl}}^{\sem{\tau}_{\gl}} \]
    as the exponential transpose of the composite
    \[ \mu_{\tau\rightarrow\tau'} \times \sem{\tau}_{\gl} \xrightarrow{\id \times \downarrow^{\tau}} \mu_{\tau \rightarrow \tau'} \times \eta_{\tau} \xrightarrow{（\app_{\tau'}^{\tau}, \epsilon）} \mu_{\tau'} \xrightarrow{\uparrow^{\tau'}} \sem{\tau'}_{\gl}\]

    and the reification map
    \[ \downarrow^{\tau\rightarrow\tau'} : {\sem{\tau'}_{\gl}}^{\sem{\tau}_{\gl}} \rightarrow \eta_{\tau \rightarrow \tau'} \] as the composite
    \[ {\sem{\tau'}_{\gl}}^{\sem{\tau}_{\gl}} \xrightarrow{(\downarrow^{\tau'})^{(\uparrow^{\tau} v_{\tau})}} {\eta_{\tau'}}^{\nu_{\tau}} \xrightarrow[\cong]{(\abs_{\tau\rightarrow\tau'} , \id)} \eta_{\tau\rightarrow\tau'}\]
    where \( v_{\tau} = (\var_{\tau} , \id) : \nu_{\tau} \rightarrow \mu_{\tau}\).
  \end{itemize}
\end{definition}

\begin{definition}[Forgetful semantic projection]
  The assignments
  \begin{align*}
    \pi : \gl &\rightarrow \cl \\
    (R, q, \Delta) &\mapsto \Delta \\\\
    \pi_{\textrm{mor}} : \gl[(R,q,\Delta), (R', q', \Delta')] &\rightarrow \cl[\Delta, \Delta'] \\
    (d, \delta) &\mapsto \delta \\
  \end{align*}

  form a functor \( \gl \rightarrow \cl \) which \emph{forgets the syntax} leaving only
  the semantics in objects and morphisms of the gluing category.
\end{definition}

The following theorem follows immediately from the definitions of the
reification and reflection maps above, and will prove crucial when
demonstrating that our normalization function computes normal forms with the
same semantics as the input term.

\begin{theorem}[Reification and reflection preserve semantics]\label{thm:reif-refl-sempres}
  For each type \( \tau \in \types \), we have the identities
  \[
    \pi (\uparrow^{\tau}) = \id_{\tau} = \pi(\downarrow^{\tau})
  \]
\end{theorem}

\begin{proof}
  The proof proceeds, like the definitions of the reification/reflection maps, by induction on the structure of types:
  \begin{itemize}
    \item For a base type \( \theta \in T\), the reflection map is
          \( \uparrow^{\theta} = \id_{\mu_{\theta}}\). By functoriality of the interpretation
          \( \sem{-}_\gl : \cl \rightarrow \gl \) and
          Lemma~\ref{lem:sem-pi-is-id-endofunctor}, we have that
          \( \semproj (\id_{\mu_{\theta}}) = \id_{\sem{\theta}_{\cl}}\), as required. The
          reification map is
          \( \downarrow^{\theta} = \mu_{\theta} \xrightarrow[\cong]{\incl_{\theta}} \eta_{\theta} \) whose semantic
          component is the identity by Definition~\ref{def:glued-algebra}.

    \item For the empty product/unit type \( \termob \), the reflection map
          \( \uparrow^{\termob} \) is the unique arrow from \( \mu_{\termob}\) into the
          terminal object of the gluing category. The interpretation
          \( \sem{-}_{\gl}\) preserves the cartesian closed structure so that
          \( \mu_{\theta} = \termob \) and unique arrow in question is forced to be the
          identity in \( \gl \), whose semantic component is also the identity
          in \( \cl \).

          The reification map \( \downarrow^{\termob} \) is the \( \unit \) operation for
          the glued algebra and has the identity as its semantic component by
          definition.
    \item For \( \tau, \tau' \in \types\), the reflection map \( \uparrow^{\tau\times\tau'}\) for
          their product is defined as the pair of the following composites:
          \begin{align*}
            &\mu_{\tau*\tau'} \xrightarrow{(\fst_{\tau}^{\tau'}, \pi_{1})} \mu_{\tau} \xrightarrow{\uparrow^{\tau}} \sem{\tau}_{\gl} \\
            &\mu_{tau*\tau'} \xrightarrow{(\snd_{\tau'}^{\tau}, \pi_{2})} \mu_{\tau'} \xrightarrow{\uparrow^{\tau'}} \sem{\tau'}_{\gl} \\
          \end{align*} so that
          \begin{align*}
            \semproj (\uparrow^{\tau\times\tau'}) &= (\semproj (\uparrow^{\tau}) \circ \pi_{1}) \times (\semproj(\uparrow^{\tau'}) \circ \pi_{2}) \\
                                &= (\id \circ \pi_{1}) \times (\id \circ \pi_{2}) && \textrm{(by the induction hypothesis)} \\
                                &= \pi_{1} \times \pi_{2}
          \end{align*}
          which is the identity on \( \sem{\tau}_{\cl} \times \sem{\tau'}_{\cl} \) as
          required.

          The reification map \( \downarrow^{\tau\times\tau'}\) is defined as TODO
          \item For \( \tau, \tau' \in \types \), the reflection map \( \uparrow^{\tau \rightarrow \tau'}\) for the function type over these is defined as the exponential transpose of the composite
          \[ \mu_{\tau\rightarrow\tau'} \times \sem{\tau}_{\gl} \xrightarrow{\id \times \downarrow^{\tau}} \mu_{\tau \rightarrow \tau'} \times \eta_{\tau} \xrightarrow{（\app_{\tau'}^{\tau}, \epsilon）} \mu_{\tau'} \xrightarrow{\uparrow^{\tau'}} \sem{\tau'}_{\gl}\] whence

            \begin{align*}
              \semproj (\uparrow^{\tau \rightarrow \tau'}) &= \semproj (\reallywidetilde{\uparrow^{\tau} \circ（\app_{\tau'}^{\tau}, \epsilon）\circ (\id \times \downarrow^{\tau})}) \\
                                    &= \reallywidetilde{\semproj (\uparrow^{\tau}) \circ \semproj (\app_{\tau'}^{\tau},\epsilon) \circ \semproj (\id \times \downarrow^{\tau})} && \textrm{(by functoriality of $\semproj$)} \\
                                    &= \reallywidetilde{\id \circ \epsilon \circ (\id \times \id)} && \textrm{(induction hypothesis, definition of $\semproj$)} \\
                                    &= \reallywidetilde{\id \circ \id} && \textrm{(UP of the transpose, and since $\widetilde{\id} = \id$)} \\
                                    &= \widetilde{\id} \\
                                    &= \id \\
            \end{align*} as required.

            Now the reification map \( \downarrow^{\tau \rightarrow \tau'} \) is defined as the composite
          \[ (\abs_{\tau \rightarrow \tau'}, \id) \circ (\downarrow^{\tau'})^{(\uparrow^{\tau} v_{\tau})}\] so that
          \begin{align*}
            \semproj(\downarrow^{\tau\rightarrow\tau'}) &= \semproj(\abs_{\tau \rightarrow \tau'}, \id) \circ {(\semproj \downarrow^{\tau'})}^{\semproj(\uparrow^{\tau}) \circ \semproj(v_{\tau})} \\
                               &= \id \circ {(\id)}^{\id \circ \id} && \textrm{(induction hypothesis)} \\
                               &= {\id}^{\id} \\
                               &= \id^{*} \circ \id_{*} \\
          \end{align*}
          which is the identity on the exponential
          \( \sem{{\tau'}}_{\cl}^{\sem{\tau}_{\cl}}\) in the classifying category.
  \end{itemize}
\end{proof}

\subsection{A promise kept: a normalization function}
Having performed reify-reflect yoga at each type, we have established the
desired diagram from Section~\ref{sec:taking-stock}. We can now define a
function \( \nf_{\tau}^{\Gamma} : \mathfrak{L}_{\tau}(\Gamma) \rightarrow \mathfrak{Nf}_{\tau}(\Gamma)\) as the
composite

\[ \mathfrak{L}_{\tau}(\Gamma) \xrightarrow{l_{\tau}} \tm(\tau)(\Gamma) \xrightarrow{\sem{-}} \gl [\sem{\Gamma}, \sem{\tau}] \xrightarrow{(\uparrow_{\Gamma} v_{\Gamma})^{*} \circ {\downarrow^{\tau}}_{*}} \gl [\yoneda(\Gamma), \eta_{\tau}] \xrightarrow[\cong]{(d,\delta) \mapsto d(\id_{\Gamma})} \nfpsh(\Gamma) \]

where
\begin{align*}
  \uparrow_{\Gamma} &= \prod_{(x:\tau)\in\Gamma} \uparrow^{\tau} \\
  v_{\Gamma} &= \yonedabar(\Gamma) \xrightarrow{\cong} \prod_{(x:\tau)\in\Gamma}\nu_{\tau} \xrightarrow{\prod_{(x:\tau)\in\Gamma} v_{\tau}} \prod_{(x:\tau)\in\Gamma}\mu_{\tau} \\
\end{align*}

recalling that \( \nu_{\tau} \xrightarrow{v_{\tau}} \mu_{\tau}\) is the \( \var_{\tau} \)
operation in the \( \NN \)-algebra on the gluing category.

That is, since the final isomorphism in the composite is a form of the Yoneda
lemma and hence given by evaluation at the identity, we have for each term $t$
that \( \nf_{\tau,\Gamma}(t) = (\downarrow^{\tau} \sem{\Gamma \vdash t : \tau} \uparrow_{\Gamma} v_{\Gamma}) (\id_{\Gamma}) \)

The function we've defined takes open terms to normal forms, but it remains to
establish the various correctness properties characterizing a normalization
function. The laborious setup work of this chapter turns out to allow us to do
so with ease.

\subsection{Reaping what we've sown: easy proofs of correctness properties}
\begin{theorem}[Normalization respects computational equality]
  For every pair of terms \( t, t' \in \mathfrak{L}_{\tau}(\Gamma) \), if
  \( t \equiv_{\beta\eta\alpha} t' \) then \( {\nf}\,_{\tau}^{\Gamma}(t) = \nf\,_{\tau}^{\Gamma}(t')\).
\end{theorem}
\begin{proof}
  \( \beta\eta\alpha \)-equivalent terms have the same interpretation in the classifying
  category, because the classifying category is quotiented by definitional
  equality. Symbolically, we have \( l_{\tau}(t) = l_{\tau}(t')\) from which the
  required equality is immediate by the definition of the normalization function
  as a composite starting with \( l_{\tau}\).
\end{proof}

\begin{lemma}\label{lem:sem-pi-is-id-endofunctor}
  The composite \( \semproj \circ \sem{-} : \cl \rightarrow \cl \) is the identity endofunctor on \( \cl \).
\end{lemma}
\begin{proof}
  This follows from Theorem~\ref{thm:classifying alg theory}. In particular,
  since \( \cl \) is the initial category with a model of the lambda calculus,
  we have that there is a unique functor \( \cl \rightarrow \cl \) preserving the
  cartesian closed structure and the lambda algebra. The identity preserves the
  cartesian closed structure and the lambda algebra, so that uniqueness forces
  the desired equality.
\end{proof}

\begin{theorem}[Semantics preservation]
  The following diagram commutes for every type \( \tau \in \types \):
  % https://q.uiver.app/?q=WzAsMyxbMCwwLCJcXG1hdGhmcmFre0x9X1xcdGF1Il0sWzIsMCwiXFxtYXRoZnJha3tOZn1fXFx0YXUiXSxbMSwxLCJcXG1hdGhmcmFre1RtfShcXHRhdSkiXSxbMCwxLCJcXHRleHRybXtuZn1fXFx0YXUiXSxbMCwyLCJsX1xcdGF1IiwyXSxbMSwyLCJuX1xcdGF1Il1d
  \[\begin{tikzcd}
      {\mathfrak{L}_\tau} && {\mathfrak{Nf}_\tau} \\
      & {\mathfrak{Tm}(\tau)}
      \arrow["{\textrm{nf}_\tau}", from=1-1, to=1-3]
      \arrow["{l_\tau}"', from=1-1, to=2-2]
      \arrow["{n_\tau}", from=1-3, to=2-2]
    \end{tikzcd}\]
\end{theorem}
\begin{proof}
  Per the version of the Yoneda lemma from Definition~\ref{def:yonedabar}, we
  have that the composite \( n_{\tau} \circ ((d, \delta) \mapsto d(\id))\) of the gluing map for
  normal forms with the isomorphism witnessing the Yoneda lemma is the semantic
  projection \( \semproj \). So it suffices to show that
  \( \semproj (\downarrow^{\tau} \sem{\Gamma \vdash t : \tau}_{\gl} (\uparrow_{\Gamma}v_{\Gamma}) ) = \sem{\Gamma \vdash t : \tau}_{\cl} \).
  By Lemma~\ref{lem:sem-pi-is-id-endofunctor}, the interpretation of terms in
  the gluing category extends the interpretation of terms in the classifying
  category, so that
  \( \semproj (\sem{\Gamma \vdash t : \tau}_{\gl}) = \sem{\Gamma \vdash t : \tau}_{\cl}\). Now the desired
  equality follows from observing that the semantic component of each gluing
  morphism \( \downarrow^{\tau} \), \( \uparrow^{\tau}\), and \( v_{\tau} \) each are the identity in the
  semantic component, by Theorem~\ref{thm:reif-refl-sempres} and
  Definition~\ref{def:glued-algebra}.
\end{proof}

\section{Looking forward: ``blah'' by gluing}

\chapter*{Conclusion}
\addcontentsline{toc}{chapter}{Conclusion}
\chaptermark{Conclusion}
\markboth{Conclusion}{Conclusion}
\setcounter{chapter}{4}
\setcounter{section}{0}

That's it for now.

% If you feel it necessary to include an appendix, it goes here.
% \appendix
% \chapter{The First Appendix}

% This is where endnotes are supposed to go, if you have them.
% I have no idea how endnotes work with LaTeX.

\backmatter% backmatter makes the index and bibliography appear properly in the t.o.c...

% if you're using bibtex, the next line forces every entry in the bibtex file to be included
% in your bibliography, regardless of whether or not you've cited it in the thesis.
\nocite{*}

% Rename my bibliography to be called "Works Cited" and not "References" or ``Bibliography''
% \renewcommand{\bibname}{Works Cited}

% \bibliographystyle{bsts/mla-good} % there are a variety of styles available;
% \bibliographystyle{plainnat}
% replace ``plainnat'' with the style of choice. You can refer to files in the bsts or APA 
% subfolder, e.g.
\printbibliography[heading=bibintoc]
% \bibliographystyle{APA/apa-good}  % or
% \bibliography{thesis}
% Comment the above two lines and uncomment the next line to use biblatex-chicago.
% \printbibliography[heading=bibintoc]

% Finally, an index would go here... but it is also optional.
\end{document}
